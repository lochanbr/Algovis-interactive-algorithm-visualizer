<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrainwareðŸ§  Algorithms</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
        }
        .logo {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            z-index: 1000;
            opacity: 0.9;
            transition: opacity 0.3s ease;
        }
        .logo:hover {
            opacity: 1;
        }
        h1 {
            color: #00ffff;
            text-shadow: 
                0 0 10px #00ffff,
                0 0 20px #00ffff,
                0 0 40px #00ffff,
                0 0 80px #00ffff;
            margin-bottom: 40px;
            font-size: 3em;
            font-weight: bold;
            animation: algorithmGlow 2s ease-in-out infinite alternate;
        }
        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 1000px;
            padding: 20px;
        }
        .algorithm-card {
            background-color: #1e1e1e;
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
        }
        .algorithm-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        .algorithm-name {
            font-size: 1.5em;
            color: #00ffff;
            margin-bottom: 10px;
        }
        .algorithm-description {
            color: #a0a0a0;
            font-size: 0.9em;
            line-height: 1.4;
        }
        a {
            text-decoration: none;
        }
        .category-bar{
            display:flex;
            gap:12px;
            margin-bottom:18px;
            align-items:center;
        }
        .category-btn{
            padding:8px 14px;
            border-radius:8px;
            background:#222;
            color:#e0e0e0;
            border:1px solid #00b8c4;
            cursor:pointer;
            box-shadow:0 0 8px rgba(0,184,196,0.06);
        }
        .category-btn.active{ background:#00ffff;color:#121212;box-shadow:0 0 14px rgba(0,255,255,0.16); }
        
        /* Explanation button and modal styles */
        .explanation-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background:bottom;
            border: none;
            color: rgb(255, 255, 255);
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .explanation-btn:hover {
            background: #ff8c42;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }
        
        .algorithm-card {
            position: relative;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: #1e1e1e;
            margin: 5% auto;
            padding: 30px;
            border: 2px solid #00ffff;
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            top: 15px;
            right: 20px;
            transition: color 0.3s ease;
        }
        
        .close:hover {
            color: #00ffff;
        }
        
        .modal h2 {
            color: #00ffff;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.8em;
            text-shadow: 0 0 5px #00ffff;
        }
        
        .modal p {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .modal .complexity-info {
            background: #0d0d0d;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            margin-top: 20px;
        }
        
        .modal .complexity-info h3 {
            color: #ffd54f;
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .modal .complexity-info p {
            margin: 5px 0;
            color: #b0b0b0;
            font-family: monospace;
        }
        
        /* Text Logo Styles */
        .text-logo {
            text-align: center;
            margin: 20px 0;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        .logo-brain {
            font-size: 3em;
            display: inline-block;
            animation: brainPulse 2s ease-in-out infinite;
            margin-right: 10px;
        }
        
        .logo-text {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(45deg, #00ffff, #ff6b9d, #c44569, #f8b500);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        @keyframes brainPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes algorithmGlow {
            0% { 
                text-shadow: 
                    0 0 10px #00ffff,
                    0 0 20px #00ffff,
                    0 0 40px #00ffff,
                    0 0 80px #00ffff;
            }
            100% { 
                text-shadow: 
                    0 0 20px #00ffff,
                    0 0 30px #00ffff,
                    0 0 60px #00ffff,
                    0 0 120px #00ffff,
                    0 0 160px #00ffff;
            }
        }

        /* Magical Cursor Styles */
        body { cursor: none; overflow-x: hidden; }
        
        .magic-cursor {
            position: fixed;
            top: 0; left: 0;
            width: 24px; height: 24px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 10000;
            mix-blend-mode: screen;
        }
        
        .cursor-core {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: radial-gradient(circle, 
                rgba(255, 105, 180, 0.9) 0%, 
                rgba(138, 43, 226, 0.8) 30%, 
                rgba(75, 0, 130, 0.6) 60%, 
                rgba(255, 215, 0, 0.4) 80%, 
                transparent 100%);
            box-shadow: 
                0 0 20px rgba(255, 105, 180, 0.8),
                0 0 40px rgba(138, 43, 226, 0.6),
                0 0 60px rgba(75, 0, 130, 0.4);
            animation: magicPulse 2s ease-in-out infinite alternate;
        }
        
        .cursor-glow {
            position: absolute;
            inset: -10px;
            border-radius: 50%;
            background: radial-gradient(circle, 
                rgba(255, 215, 0, 0.3) 0%, 
                rgba(255, 105, 180, 0.2) 40%, 
                transparent 70%);
            filter: blur(8px);
            animation: magicGlow 3s ease-in-out infinite;
        }
        
        @keyframes magicPulse {
            0% { transform: scale(1) rotate(0deg); opacity: 0.9; }
            100% { transform: scale(1.2) rotate(180deg); opacity: 1; }
        }
        
        @keyframes magicGlow {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.3); }
        }
        
        .magic-particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            border-radius: 50%;
            mix-blend-mode: screen;
            animation: sparkle 1.5s ease-out forwards;
        }
        
        .particle-star {
            width: 8px; height: 8px;
            background: radial-gradient(circle, 
                rgba(255, 215, 0, 1) 0%, 
                rgba(255, 105, 180, 0.8) 50%, 
                transparent 100%);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        
        .particle-sparkle {
            width: 6px; height: 6px;
            background: radial-gradient(circle, 
                rgba(138, 43, 226, 1) 0%, 
                rgba(75, 0, 130, 0.8) 50%, 
                transparent 100%);
            box-shadow: 0 0 8px rgba(138, 43, 226, 0.9);
        }
        
        .particle-bubble {
            width: 12px; height: 12px;
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 255, 255, 0.9) 0%, 
                rgba(173, 216, 230, 0.6) 40%, 
                rgba(138, 43, 226, 0.3) 100%);
            box-shadow: 0 0 15px rgba(173, 216, 230, 0.7);
        }
        
        @keyframes sparkle {
            0% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(0) rotate(0deg); 
            }
            20% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.2) rotate(90deg); 
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.3) rotate(360deg); 
            }
        }
        
        .explosion-particle {
            position: fixed;
            pointer-events: none;
            z-index: 9998;
            border-radius: 50%;
            mix-blend-mode: screen;
            animation: explode 0.8s ease-out forwards;
        }
        
        @keyframes explode {
            0% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(0.5); 
            }
            50% { 
                opacity: 0.8; 
                transform: translate(-50%, -50%) scale(1.5); 
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.2); 
            }
        }
        
        .magic-ripple {
            position: fixed;
            pointer-events: none;
            z-index: 9997;
            border: 2px solid rgba(255, 105, 180, 0.8);
            border-radius: 50%;
            mix-blend-mode: screen;
            animation: rippleExpand 1s ease-out forwards;
        }
        
        @keyframes rippleExpand {
            0% { 
                width: 10px; height: 10px;
                opacity: 1; 
                transform: translate(-50%, -50%); 
            }
            100% { 
                width: 100px; height: 100px;
                opacity: 0; 
                transform: translate(-50%, -50%); 
                border-width: 0;
            }
        }
    </style>


</head>
<body>
    <div class="text-logo">
        <span class="logo-brain">ðŸ§ </span>
        <span class="logo-text">BrainWare</span>
    </div>
    <h1>Algorithms</h1>
    <div class="category-bar" role="tablist" aria-label="Algorithm categories">
        <button class="category-btn active" data-category="all">All</button>
        <button class="category-btn" data-category="sorting">Sorting</button>
        <button class="category-btn" data-category="search">Search</button>
        <button class="category-btn" data-category="datamanipulation">Data Manipulation</button>
    </div>

    <div class="algorithm-grid">
        <a href="visualizer.html?algorithm=bubbleSort" data-category="sorting">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('bubbleSort')">*</button>
                <div class="algorithm-name">Bubble Sort</div>
                <div class="algorithm-description">
                    A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.
                </div>
                
            </div>
        </a>
        
        <a href="visualizer.html?algorithm=insertionSort" data-category="sorting">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('insertionSort')">*</button>
                <div class="algorithm-name">Insertion Sort</div>
                <div class="algorithm-description">
                    Builds the final sorted array one item at a time, by repeatedly inserting a new element into the sorted portion of the array.
                </div>
                
            </div>
        </a>
        
        <a href="visualizer.html?algorithm=selectionSort" data-category="sorting">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('selectionSort')">*</button>
                <div class="algorithm-name">Selection Sort</div>
                <div class="algorithm-description">
                    Divides the array into a sorted and unsorted region, repeatedly selecting the smallest element from the unsorted region.
                </div>
                
            </div>
        </a>
        
        <a href="visualizer.html?algorithm=quickSort" data-category="sorting">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('quickSort')">*</button>
                <div class="algorithm-name">Quick Sort</div>
                <div class="algorithm-description">
                    An efficient sorting algorithm using divide-and-conquer strategy. Picks a 'pivot' element and partitions the array around it.
                </div>
                
            </div>
        </a>
        
        <a href="visualizer.html?algorithm=mergeSort" data-category="sorting">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('mergeSort')">*</button>
                <div class="algorithm-name">Merge Sort</div>
                <div class="algorithm-description">
                    A divide-and-conquer algorithm that recursively breaks down the array into smaller subarrays, sorts them, and merges them back together.
                </div>
                
            </div>
        </a>
        
        <a href="visualizer.html?algorithm=linearSearch" data-category="search">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('linearSearch')">*</button>
                <div class="algorithm-name">Linear Search</div>
                <div class="algorithm-description">
                    Searches each element in sequence until the target is found. Visualization will highlight elements as they are compared.
                </div>
            </div>
        </a>

        <a href="visualizer.html?algorithm=binarySearch" data-category="search">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('binarySearch')">*</button>
                <div class="algorithm-name">Binary Search</div>
                <div class="algorithm-description">
                    Efficient search on sorted arrays using divide-and-conquer. Visualization will show mid selection and narrowing range.
                </div>
            </div>
        </a>

        <a href="visualizer.html?algorithm=insertMethod" data-category="datamanipulation">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('insertMethod')">*</button>
                <div class="algorithm-name">Insert Method</div>
                <div class="algorithm-description">
                    Inserts a new element into a sorted array while maintaining order. Shows the search for insertion position and the insertion process with graph visualization.
                </div>
            </div>
        </a>

        <a href="visualizer.html?algorithm=deleteMethod" data-category="datamanipulation">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('deleteMethod')">*</button>
                <div class="algorithm-name">Delete Method</div>
                <div class="algorithm-description">
                    Removes a specific element from an array. Visualizes the search process and element removal with decision tree graph.
                </div>
            </div>
        </a>

        
        

        <a href="visualizer.html?algorithm=treeDfs" data-category="datamanipulation">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('treeDfs')">*</button>
                <div class="algorithm-name"> DFS Traversal</div>
                <div class="algorithm-description">
                    Depth-First Search tree traversal that explores each branch completely before backtracking. Shows pre-order traversal.
                </div>
            </div>
        </a>

        <a href="visualizer.html?algorithm=treeBfs" data-category="datamanipulation">
            <div class="algorithm-card">
                <button class="explanation-btn" onclick="event.preventDefault(); showExplanation('treeBfs')">*</button>
                <div class="algorithm-name"> BFS Traversal</div>
                <div class="algorithm-description">
                    Breadth-First Search tree traversal that visits nodes level by level, exploring all nodes at current depth first.
                </div>
            </div>
        </a>
    </div>

    <!-- Explanation Modal -->
    <div id="explanationModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2 id="modalTitle"></h2>
            <div id="modalContent"></div>
        </div>
    </div>

    <!-- Magical Cursor Container -->
    <div id="magicCursor" class="magic-cursor" aria-hidden="true">
        <div class="cursor-glow"></div>
        <div class="cursor-core"></div>
    </div>
</body>
<script>
// Category filter for landing page
(function(){
    const buttons = Array.from(document.querySelectorAll('.category-btn'));
    const cards = Array.from(document.querySelectorAll('.algorithm-grid a'));

    function setCategory(cat){
        buttons.forEach(b=> b.classList.toggle('active', b.dataset.category === cat));
        cards.forEach(a=>{
            const cardCat = a.dataset.category || 'sorting';
            if (cat === 'all' || cardCat === cat) {
                a.style.display = '';
            } else {
                a.style.display = 'none';
            }
        });
    }

    buttons.forEach(b => b.addEventListener('click', ()=> setCategory(b.dataset.category)));
    // initial state
    setCategory('all');
})();

// Algorithm explanations and modal functionality
const algorithmExplanations = {
    bubbleSort: {
        title: "Bubble Sort Algorithm",
        description: "Bubble Sort is a simple comparison-based sorting algorithm. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The algorithm gets its name from the way smaller elements 'bubble' to the top of the list.",
        howItWorks: "The algorithm works by making multiple passes through the array. In each pass, it compares adjacent elements and swaps them if they're in the wrong order. After each pass, the largest element 'bubbles up' to its correct position at the end of the array. This process continues until no more swaps are needed.",
        complexity: {
            time: "O(nÂ²) - Quadratic time complexity",
            space: "O(1) - Constant space complexity",
            best: "O(n) - When array is already sorted",
            worst: "O(nÂ²) - When array is sorted in reverse order"
        },
        useCases: "Bubble Sort is mainly used for educational purposes due to its simplicity, but it's not practical for large datasets due to its poor performance."
    },
    insertionSort: {
        title: "Insertion Sort Algorithm",
        description: "Insertion Sort is a simple sorting algorithm that builds the final sorted array one item at a time. It works similarly to how you might sort playing cards in your hands.",
        howItWorks: "The algorithm divides the array into a sorted and an unsorted region. It picks elements from the unsorted region and inserts them into the correct position in the sorted region. For each element, it compares it with elements in the sorted region and shifts them to make room for the new element.",
        complexity: {
            time: "O(nÂ²) - Quadratic time complexity",
            space: "O(1) - Constant space complexity",
            best: "O(n) - When array is already sorted",
            worst: "O(nÂ²) - When array is sorted in reverse order"
        },
        useCases: "Insertion Sort is efficient for small datasets and is stable, making it useful in hybrid sorting algorithms like Timsort."
    },
    selectionSort: {
        title: "Selection Sort Algorithm",
        description: "Selection Sort is an in-place comparison sorting algorithm. It divides the input list into two parts: a sorted sublist and an unsorted sublist.",
        howItWorks: "The algorithm repeatedly finds the minimum element from the unsorted part and puts it at the beginning of the unsorted part. This process continues until the entire array is sorted. It maintains two subarrays: one that is sorted and one that is unsorted.",
        complexity: {
            time: "O(nÂ²) - Quadratic time complexity",
            space: "O(1) - Constant space complexity",
            best: "O(nÂ²) - Always performs the same number of comparisons",
            worst: "O(nÂ²) - Same as best case"
        },
        useCases: "Selection Sort is simple to implement and has the advantage of making a minimal number of writes to memory, making it useful when memory write operations are costly."
    },
    quickSort: {
        title: "Quick Sort Algorithm",
        description: "Quick Sort is a highly efficient divide-and-conquer sorting algorithm. It works by selecting a 'pivot' element and partitioning the array around the pivot.",
        howItWorks: "The algorithm picks a pivot element and rearranges the array so that all elements smaller than the pivot come before it, and all elements greater than the pivot come after it. This process is called partitioning. Then it recursively sorts the sub-arrays before and after the pivot.",
        complexity: {
            time: "O(n log n) average, O(nÂ²) worst case",
            space: "O(log n) - Due to recursive calls",
            best: "O(n log n) - When pivot divides array evenly",
            worst: "O(nÂ²) - When pivot is always the smallest or largest element"
        },
        useCases: "Quick Sort is widely used in practice due to its excellent average-case performance and is the default sorting algorithm in many programming languages."
    },
    mergeSort: {
        title: "Merge Sort Algorithm",
        description: "Merge Sort is a stable, divide-and-conquer sorting algorithm that works by dividing the array into two halves, sorting them separately, and then merging them back together.",
        howItWorks: "The algorithm recursively divides the array into smaller subarrays until each subarray has only one element. Then it merges these subarrays back together in a sorted manner, comparing elements from each subarray and placing them in the correct order.",
        complexity: {
            time: "O(n log n) - Guaranteed performance",
            space: "O(n) - Requires additional memory for merging",
            best: "O(n log n) - Always the same",
            worst: "O(n log n) - Always the same"
        },
        useCases: "Merge Sort is preferred when you need a stable sort with guaranteed O(n log n) performance, especially for large datasets or when working with linked lists."
    },
    linearSearch: {
        title: "Linear Search Algorithm",
        description: "Linear Search is the simplest search algorithm that checks each element in the list sequentially until the target value is found or the list is exhausted.",
        howItWorks: "The algorithm starts from the first element and compares it with the target value. If it matches, the search is successful. If not, it moves to the next element and repeats the process until either the target is found or all elements have been checked.",
        complexity: {
            time: "O(n) - Linear time complexity",
            space: "O(1) - Constant space complexity",
            best: "O(1) - Target found at first position",
            worst: "O(n) - Target not found or at last position"
        },
        useCases: "Linear Search is used when the data is unsorted or when you need to search through a small dataset. It's also useful when you need to find all occurrences of a value."
    },
    binarySearch: {
        title: "Binary Search Algorithm",
        description: "Binary Search is an efficient search algorithm that works on sorted arrays by repeatedly dividing the search interval in half.",
        howItWorks: "The algorithm compares the target value with the middle element of the array. If they match, the search is successful. If the target is smaller, it searches the left half. If larger, it searches the right half. This process continues until the target is found or the search space is exhausted.",
        complexity: {
            time: "O(log n) - Logarithmic time complexity",
            space: "O(1) - Constant space complexity",
            best: "O(1) - Target found at middle position",
            worst: "O(log n) - Target not found"
        },
        useCases: "Binary Search is extremely efficient for large sorted datasets and is commonly used in computer science applications like database indexing and searching algorithms."
    },
    insertMethod: {
        title: "Insert Method Algorithm",
        description: "The Insert Method is used to add a new element to a sorted array while maintaining the sorted order. It finds the correct position for the new element and inserts it there.",
        howItWorks: "The algorithm searches through the sorted array to find the appropriate position where the new element should be inserted. It compares the new element with existing elements to determine where it fits in the sorted sequence, then shifts elements as necessary to make room for the insertion.",
        complexity: {
            time: "O(n) - Linear time complexity",
            space: "O(1) - Constant space complexity",
            best: "O(1) - Insert at the end",
            worst: "O(n) - Insert at the beginning"
        },
        useCases: "Insert Method is commonly used in database systems, priority queues, and any application that needs to maintain sorted data structures while allowing dynamic insertions."
    },
    deleteMethod: {
        title: "Delete Method Algorithm",
        description: "The Delete Method removes a specific element from an array. It first searches for the element and then removes it, potentially shifting other elements to fill the gap.",
        howItWorks: "The algorithm performs a linear search to locate the target element in the array. Once found, it removes the element and shifts all subsequent elements one position to the left to fill the gap left by the deleted element.",
        complexity: {
            time: "O(n) - Linear time complexity",
            space: "O(1) - Constant space complexity",
            best: "O(1) - Delete last element",
            worst: "O(n) - Delete first element"
        },
        useCases: "Delete Method is essential in dynamic data structures, database management systems, and any application that needs to remove specific elements while maintaining data integrity."
    },
    dfs: {
        title: "DFS Path Finding Algorithm",
        description: "Depth-First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It uses a stack data structure (LIFO - Last In, First Out).",
        howItWorks: "DFS starts at the source node and explores each branch as far as possible before backtracking. It uses a stack to keep track of nodes to visit next. The algorithm continues until it finds the target or explores all possible paths.",
        complexity: {
            time: "O(V + E) - Where V is vertices and E is edges",
            space: "O(V) - Stack space for recursion",
            best: "O(1) - Target found immediately",
            worst: "O(V + E) - Must explore entire graph"
        },
        useCases: "DFS is used in maze solving, topological sorting, cycle detection, and when you need to explore all possible paths or find any valid path (not necessarily the shortest)."
    },
    bfs: {
        title: "BFS Path Finding Algorithm",
        description: "Breadth-First Search (BFS) is a graph traversal algorithm that explores all neighbors at the current depth before moving to the next level. It uses a queue data structure (FIFO - First In, First Out).",
        howItWorks: "BFS starts at the source node and explores all its neighbors first, then moves to the next level of neighbors. It guarantees finding the shortest path in unweighted graphs by exploring nodes level by level.",
        complexity: {
            time: "O(V + E) - Where V is vertices and E is edges",
            space: "O(V) - Queue space for storing nodes",
            best: "O(1) - Target found immediately",
            worst: "O(V + E) - Must explore entire graph"
        },
        useCases: "BFS is used for finding shortest paths in unweighted graphs, level-order traversal, social network analysis, and when you need the shortest path or want to explore nodes level by level."
    },
    treeDfs: {
        title: "Tree DFS Traversal Algorithm",
        description: "Tree Depth-First Search (DFS) is a tree traversal algorithm that explores as deep as possible along each branch before backtracking. It uses recursion and visits nodes in pre-order: root, left subtree, right subtree.",
        howItWorks: "DFS starts at the root node and visits it. Then it recursively traverses the left subtree completely, followed by the right subtree. This creates a deep exploration pattern where we go all the way down one branch before exploring other branches.",
        complexity: {
            time: "O(n) - Where n is the number of nodes in the tree",
            space: "O(h) - Where h is the height of the tree (recursion stack)",
            best: "O(log n) - For balanced trees",
            worst: "O(n) - For skewed trees (like linked lists)"
        },
        useCases: "Tree DFS is used in expression tree evaluation, directory tree traversal, syntax tree parsing, and when you need to process nodes in pre-order, in-order, or post-order."
    },
    treeBfs: {
        title: "Tree BFS Traversal Algorithm",
        description: "Tree Breadth-First Search (BFS) is a tree traversal algorithm that visits nodes level by level, exploring all nodes at the current depth before moving to the next level. It uses a queue data structure.",
        howItWorks: "BFS starts at the root and adds it to a queue. Then it processes nodes from the queue, visiting each node and adding its children to the queue. This ensures all nodes at level 1 are visited before any nodes at level 2, and so on.",
        complexity: {
            time: "O(n) - Where n is the number of nodes in the tree",
            space: "O(w) - Where w is the maximum width of the tree",
            best: "O(1) - For trees with only one node",
            worst: "O(n) - For complete binary trees"
        },
        useCases: "Tree BFS is used for level-order traversal, finding the shortest path in trees, printing tree levels, and when you need to process nodes by their distance from the root."
    }
};

// Modal functionality
function showExplanation(algorithm) {
    const modal = document.getElementById('explanationModal');
    const title = document.getElementById('modalTitle');
    const content = document.getElementById('modalContent');
    
    const explanation = algorithmExplanations[algorithm];
    if (!explanation) return;
    
    title.textContent = explanation.title;
    content.innerHTML = `
        <p><strong>Description:</strong> ${explanation.description}</p>
        <p><strong>How it works:</strong> ${explanation.howItWorks}</p>
        <div class="complexity-info">
            <h3>Time & Space Complexity</h3>
            <p><strong>Average Time:</strong> ${explanation.complexity.time}</p>
            <p><strong>Space:</strong> ${explanation.complexity.space}</p>
            <p><strong>Best Case:</strong> ${explanation.complexity.best}</p>
            <p><strong>Worst Case:</strong> ${explanation.complexity.worst}</p>
        </div>
        <p><strong>Use Cases:</strong> ${explanation.useCases}</p>
    `;
    
    modal.style.display = 'block';
}

function closeModal() {
    const modal = document.getElementById('explanationModal');
    modal.style.display = 'none';
}

// Close modal when clicking outside of it
window.onclick = function(event) {
    const modal = document.getElementById('explanationModal');
    if (event.target === modal) {
        closeModal();
    }
}
</script>

<!-- Magical Cursor Script -->
<script>
(function() {
    const cursor = document.getElementById('magicCursor');
    if (!cursor) return;

    // Cursor position and movement
    let mouseX = window.innerWidth / 2;
    let mouseY = window.innerHeight / 2;
    let cursorX = mouseX;
    let cursorY = mouseY;
    
    // Trail particles array
    let particles = [];
    let particleId = 0;
    
    // Rainbow color cycling
    let hue = 0;
    
    // Smooth cursor movement with easing
    function updateCursorPosition() {
        const ease = 0.15;
        cursorX += (mouseX - cursorX) * ease;
        cursorY += (mouseY - cursorY) * ease;
        
        cursor.style.left = cursorX + 'px';
        cursor.style.top = cursorY + 'px';
    }
    
    // Generate rainbow colors
    function getRainbowColor(offset = 0) {
        const h = (hue + offset) % 360;
        return `hsl(${h}, 80%, 65%)`;
    }
    
    // Create trail particle
    function createTrailParticle(x, y) {
        const particle = document.createElement('div');
        particle.className = 'magic-particle';
        
        // Random particle type
        const types = ['particle-star', 'particle-sparkle', 'particle-bubble'];
        const type = types[Math.floor(Math.random() * types.length)];
        particle.classList.add(type);
        
        // Random size variation for depth
        const size = 0.5 + Math.random() * 0.8;
        particle.style.transform = `translate(-50%, -50%) scale(${size})`;
        
        // Rainbow color with slight variation
        const colorOffset = Math.random() * 60 - 30;
        particle.style.background = `radial-gradient(circle, ${getRainbowColor(colorOffset)} 0%, transparent 70%)`;
        particle.style.boxShadow = `0 0 ${10 + Math.random() * 10}px ${getRainbowColor(colorOffset)}`;
        
        // Position with slight randomness
        const offsetX = (Math.random() - 0.5) * 20;
        const offsetY = (Math.random() - 0.5) * 20;
        particle.style.left = (x + offsetX) + 'px';
        particle.style.top = (y + offsetY) + 'px';
        
        document.body.appendChild(particle);
        
        // Add physics for floating effect
        const physics = {
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2 - 1,
            gravity: 0.02,
            friction: 0.98,
            life: 1.5
        };
        
        particles.push({ element: particle, physics, id: particleId++ });
        
        // Remove after animation
        setTimeout(() => {
            if (particle.parentNode) {
                particle.parentNode.removeChild(particle);
            }
        }, 1500);
    }
    
    // Update particle physics
    function updateParticles() {
        particles = particles.filter(p => {
            if (!p.element.parentNode) return false;
            
            p.physics.vy += p.physics.gravity;
            p.physics.vx *= p.physics.friction;
            p.physics.vy *= p.physics.friction;
            
            const currentX = parseFloat(p.element.style.left);
            const currentY = parseFloat(p.element.style.top);
            
            p.element.style.left = (currentX + p.physics.vx) + 'px';
            p.element.style.top = (currentY + p.physics.vy) + 'px';
            
            p.physics.life -= 0.016;
            return p.physics.life > 0;
        });
    }
    
    // Create explosion effect on click
    function createExplosion(x, y) {
        // Create ripple
        const ripple = document.createElement('div');
        ripple.className = 'magic-ripple';
        ripple.style.left = x + 'px';
        ripple.style.top = y + 'px';
        ripple.style.borderColor = getRainbowColor();
        document.body.appendChild(ripple);
        
        setTimeout(() => {
            if (ripple.parentNode) {
                ripple.parentNode.removeChild(ripple);
            }
        }, 1000);
        
        // Create explosion particles
        for (let i = 0; i < 12; i++) {
            const particle = document.createElement('div');
            particle.className = 'explosion-particle';
            
            const size = 4 + Math.random() * 8;
            particle.style.width = size + 'px';
            particle.style.height = size + 'px';
            
            const angle = (i / 12) * Math.PI * 2;
            const distance = 30 + Math.random() * 40;
            const endX = x + Math.cos(angle) * distance;
            const endY = y + Math.sin(angle) * distance;
            
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            particle.style.background = getRainbowColor(i * 30);
            particle.style.boxShadow = `0 0 10px ${getRainbowColor(i * 30)}`;
            
            document.body.appendChild(particle);
            
            // Animate to end position
            setTimeout(() => {
                particle.style.left = endX + 'px';
                particle.style.top = endY + 'px';
            }, 10);
            
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 800);
        }
        
        // Play sparkle sound (optional - commented out for now)
        // const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT');
        // audio.play().catch(() => {}); // Ignore errors if audio fails
    }
    
    // Mouse move handler
    let lastTrailTime = 0;
    document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        // Create trail particles based on movement speed
        const now = Date.now();
        if (now - lastTrailTime > 50) { // Throttle particle creation
            const speed = Math.sqrt(
                Math.pow(e.movementX || 0, 2) + 
                Math.pow(e.movementY || 0, 2)
            );
            
            if (speed > 1) {
                createTrailParticle(mouseX, mouseY);
                lastTrailTime = now;
            }
        }
    });
    
    // Click handler
    document.addEventListener('mousedown', (e) => {
        createExplosion(e.clientX, e.clientY);
    });
    
    // Hide cursor when leaving window
    document.addEventListener('mouseleave', () => {
        cursor.style.opacity = '0';
    });
    
    document.addEventListener('mouseenter', () => {
        cursor.style.opacity = '1';
    });
    
    // Animation loop
    function animate() {
        updateCursorPosition();
        updateParticles();
        
        // Cycle rainbow colors
        hue = (hue + 0.5) % 360;
        
        // Update cursor colors
        const core = cursor.querySelector('.cursor-core');
        if (core) {
            core.style.background = `radial-gradient(circle, 
                ${getRainbowColor(0)} 0%, 
                ${getRainbowColor(60)} 30%, 
                ${getRainbowColor(120)} 60%, 
                ${getRainbowColor(180)} 80%, 
                transparent 100%)`;
            core.style.boxShadow = `
                0 0 20px ${getRainbowColor(0)},
                0 0 40px ${getRainbowColor(60)},
                0 0 60px ${getRainbowColor(120)}`;
        }
        
        requestAnimationFrame(animate);
    }
    
    // Start animation
    animate();
    
    // Initialize cursor position
    cursor.style.left = mouseX + 'px';
    cursor.style.top = mouseY + 'px';
})();
</script>
</html>
