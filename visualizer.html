<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Visualization</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }
        .container {
            display: flex;
            width: 100%;
            max-width: 1400px;
            gap: 20px;
            margin-top: 20px;
            /* align items to the top so the info panel (pseudocode) sits higher */
            align-items: flex-start;
        }
        
        .explanation-sidebar {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: stretch;
        }
        
        .explanation-btn {
            padding: 12px 16px;
            border-radius: 8px;
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            border: none;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
            text-align: center;
        }
        
        .explanation-btn:hover {
            background: linear-gradient(135deg, #ff8c42, #ffa726);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
        }
        
        .explanation-btn:active {
            transform: translateY(0);
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid var(--algorithm-color, #00ffff);
            box-shadow: 0 0 10px var(--algorithm-color, #00ffff);
            background-color: #0d0d0d;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }
        select, button {
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #00ffff;
            background-color: #2c2c2c;
            color: #e0e0e0;
            box-shadow: 0 0 5px #00ffff;
        }
        button {
            cursor: pointer;
            border: none;
            color: #121212;
            background-color: #00ffff;
            font-weight: bold;
            text-transform: uppercase;
        }
        button:hover {
            background-color: #00d2d2;
            box-shadow: 0 0 15px #00ffff;
        }
        button:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
        }
        .info-panel {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 12px; /* tighten vertical spacing */
            align-items: stretch;
            justify-content: flex-start;
        }
        .pseudocode-box, .message-box {
            background-color: #0d0d0d;
            border: 2px solid #00ffff;
            box-shadow: 0 0 8px #00a6ff;
            padding: 10px 12px;
            border-radius: 5px;
            white-space: pre-wrap;
            color: #e0e0e0;
        }
        .pseudocode-box{
            /* size to content: let pre determine height and remove scrollbar */
            overflow: visible;
            display: block;
            padding: 6px 8px;
            margin-top: 0; /* ensure it sits up against the top of the panel */
        }
        .pseudocode-box pre{
            display: inline-block;
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: 'Segoe UI', monospace;
            font-size: 13px;
        }
        .message-box {
            /* keep message box scrollable for long explanations */
            height: 180px;
            overflow-y: auto;
        }
        .pseudocode-box:hover{
            box-shadow: 0 0 20px #ff66cc;
            border: 2px solid #ff0066;
        }
        .info-panel h2 {
            margin-top: 0;
            font-size: 1.2em;
            color: #00ffff;
            border-bottom: 1px solid #00ffff;
            padding-bottom: 5px;
        }
        .back-button {
            margin-bottom: 20px;
        }
        /* search canvas subtle styling */
        #searchCanvas{ background: #0b0b0b; border: 2px solid rgba(0,255,255,0.06); box-shadow: 0 0 8px rgba(0,255,255,0.03); border-radius:6px }
    </style>

</head>
<body>
    <div style="display:flex;align-items:center;gap:16px;margin-bottom:18px;">
        <button class="back-button" onclick="window.location.href='3.html'" style="margin-bottom:0;">‚Üê Back to Algorithms</button>
        <button id="timeBtn" style="padding:8px 14px;border-radius:8px;background:#ffd54f;color:#121212;border:none;cursor:pointer;font-weight:500;box-shadow:0 0 8px #ffd54f;">Time Complexity</button>
    </div>
    <div id="timeComplexity" style="display:none;margin:10px 0 0 0;padding:10px 14px;background:#1a1200;border-radius:8px;border:1px solid #ffd54f;color:#fff;max-width:700px;font-size:0.98em;font-family:monospace;"></div>
    <h1>Algorithm Visualization</h1>
    <div class="container">
        <div class="explanation-sidebar">
            <button class="explanation-btn" onclick="showAlgorithmExplanation()">
                üìñ Algorithm Explanation
            </button>
            <button class="explanation-btn" onclick="showComplexityInfo()">
                ‚è±Ô∏è Time Complexity
            </button>
            <button class="explanation-btn" onclick="showHowItWorks()">
                üîß How It Works
            </button>
            <button class="explanation-btn" onclick="showUseCases()">
                üí° Use Cases
            </button>
        </div>
        
        <div class="main-content">
            <canvas id="visualizerCanvas" width="800" height="400"></canvas>
            <!-- Compact canvas to illustrate search steps (indices, left/mid/right highlights) -->
            <canvas id="searchCanvas" width="800" height="80" style="display:none;margin-top:12px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);"></canvas>
            <!-- Grid canvas for path finding algorithms -->
            <canvas id="gridCanvas" width="800" height="400" style="display:none;margin-top:12px;border-radius:6px;border:2px solid #4CAF50;background:#1a1a1a;"></canvas>
            <!-- Tree canvas for tree traversal algorithms -->
            <canvas id="treeCanvas" width="800" height="500" style="display:none;margin-top:12px;border-radius:6px;border:2px solid #9C27B0;background:#1a1a1a;"></canvas>
            <div class="controls">
                <div style="position:relative;">
                    <label for="speed-select">Speed:</label>
                    <select id="speed-select">
                        <option value="1000">Slow</option>
                        <option value="250" selected>Medium</option>
                        <option value="1">Fast</option>
                    </select>
                    <div style="display:inline-block;position:relative;margin-left:8px;">
                        <button id="customSpeedBtn" style="padding:6px 8px;border-radius:6px;background:#333;color:#e0e0e0;border:1px solid #00ffff;">Custom</button>
                        <div id="rightSpeedContainer" style="display:none;position:absolute;top:calc(100% + 8px);right:0;min-width:180px;background:#0d0d0d;border:1px solid #00ffff;padding:10px;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,0.6);z-index:10000;">
                            <label for="speed-range" style="color:#e0e0e0;margin:0 0 6px 0;font-size:14px;display:block;">Custom Speed</label>
                            <input id="speed-range" type="range" min="1" max="1000" step="1" value="250" style="width:160px;display:block;margin-bottom:8px;">
                            <div style="color:#e0e0e0;font-size:13px;">Value: <span id="speed-range-value">250</span> ms</div>
                        </div>
                    </div>
                </div>
                
                <div style="display:flex;align-items:center;gap:8px;">
                    <label for="data-input" style="margin:0;font-size:14px;color:#e0e0e0">Data:</label>
                    <input id="data-input" placeholder="e.g. 5 3 8 2 9" style="padding:8px;border-radius:4px;border:1px solid #00ffff;background:#222;color:#e0e0e0;width:220px">
                    <button id="setDataBtn" style="padding:8px;border-radius:6px;background:#00d4c4;border:none;color:#031617;cursor:pointer;font-weight:600">Set Data</button>
                </div>
                <button id="exampleDataBtn">Example Data</button>
                <button id="startBtn">Start</button>
                <button id="pauseBtn" disabled>Pause</button>
                <button id="stopBtn" disabled>Stop</button>
            </div>
        </div>
        <div class="info-panel">
            <div class="message-box">
                <h2>Explanation</h2>
                <div id="message"></div>
            </div>
            <!-- custom speed popover is anchored to the Custom button near the top; no duplicate here -->
            <div class="pseudocode-box">
                <h2>Pseudocode</h2>
                <pre id="pseudocode"></pre>
            </div>
            <!-- Current Data readout removed as requested -->
        </div>
    </div>

    <script>
        // Simple explanations for each algorithm
        const simpleExplanations = {
            bubbleSort: "Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. It continues until the list is sorted.",
            insertionSort: "Insertion Sort builds the sorted array one item at a time by inserting each new element into its correct position among the already sorted elements.",
            selectionSort: "Selection Sort divides the array into sorted and unsorted parts, repeatedly finding the smallest element from the unsorted part and moving it to the sorted part.",
            quickSort: "Quick Sort is a divide-and-conquer algorithm that picks a pivot, partitions the array around the pivot, and recursively sorts the partitions.",
            mergeSort: "Merge Sort splits the array into halves, recursively sorts each half, and then merges the sorted halves back together.",
            linearSearch: "Linear Search checks each element in the list one by one until it finds the target value or reaches the end.",
            binarySearch: "Binary Search works on sorted arrays by repeatedly dividing the search interval in half, comparing the middle element to the target, and narrowing the search range until the target is found or not present.",
            insertMethod: "Insert Method finds the correct position to insert a new value while maintaining the sorted order of the array. It searches for the appropriate position and inserts the element there.",
            deleteMethod: "Delete Method searches for a specific value in the array and removes it if found. It performs a linear search to locate the element and then removes it from the array.",
            // DFS and BFS descriptions removed
            treeDfs: "Tree DFS traverses a tree by going as deep as possible along each branch before backtracking. It visits nodes in pre-order: root, left subtree, right subtree.",
            treeBfs: "Tree BFS traverses a tree level by level, visiting all nodes at the current depth before moving to the next level. It guarantees visiting nodes in breadth-first order."
        };

    let lastConditionDetail = '';
    const timeBtn = document.getElementById('timeBtn');
    const timeComplexityEl = document.getElementById('timeComplexity');

    const complexities = {
        bubbleSort: { best: 'O(n)', avg: 'O(n^2)', worst: 'O(n^2)', space: 'O(1)' },
        insertionSort: { best: 'O(n)', avg: 'O(n^2)', worst: 'O(n^2)', space: 'O(1)' },
        selectionSort: { best: 'O(n^2)', avg: 'O(n^2)', worst: 'O(n^2)', space: 'O(1)' },
        quickSort: { best: 'O(n log n)', avg: 'O(n log n)', worst: 'O(n^2)', space: 'O(log n)' },
        mergeSort: { best: 'O(n log n)', avg: 'O(n log n)', worst: 'O(n log n)', space: 'O(n)' },
        linearSearch: { best: 'O(1)', avg: 'O(n)', worst: 'O(n)', space: 'O(1)' },
        binarySearch: { best: 'O(1)', avg: 'O(log n)', worst: 'O(log n)', space: 'O(1)' },
        insertMethod: { best: 'O(1)', avg: 'O(n)', worst: 'O(n)', space: 'O(1)' },
        deleteMethod: { best: 'O(1)', avg: 'O(n)', worst: 'O(n)', space: 'O(1)' },
        // DFS and BFS complexity information removed
        treeDfs: { best: 'O(n)', avg: 'O(n)', worst: 'O(n)', space: 'O(h)' },
        treeBfs: { best: 'O(n)', avg: 'O(n)', worst: 'O(n)', space: 'O(w)' }
    };

    timeBtn.addEventListener('click', ()=>{
        if (!timeComplexityEl) return;
        const info = complexities[selectedAlgorithm] || null;
        if (!info) {
            timeComplexityEl.textContent = 'No complexity data available.';
        } else {
            timeComplexityEl.innerHTML = `<strong>${selectedAlgorithm.replace(/([A-Z])/g,' $1').trim()}</strong><br>Best: ${info.best} &nbsp; Avg: ${info.avg} &nbsp; Worst: ${info.worst} &nbsp; Space: ${info.space}`;
        }
        timeComplexityEl.style.display = timeComplexityEl.style.display === 'none' ? 'block' : 'none';
    });
        // Get the algorithm from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const selectedAlgorithm = urlParams.get('algorithm') || 'bubbleSort';
        
        // Define color schemes for each algorithm
        const algorithmColors = {
            bubbleSort: {
                base: '#FF69B4',    // Hot Pink
                comparing: '#FF1493' // Deep Pink
            },
            insertionSort: {
                base: '#4CAF50',    // Material Green
                comparing: '#2E7D32' // Dark Green
            },
            selectionSort: {
                base: '#FFA500',    // Orange
                comparing: '#FF4500' // Orange Red
            },
            quickSort: {
                base: '#9C27B0',    // Purple
                comparing: '#6A1B9A' // Dark Purple
            },
            mergeSort: {
                base: '#2196F3',    // Blue
                comparing: '#1565C0' // Dark Blue
            }
        };

        // safe lookup for selected algorithm colors (fallback if missing)
        const colorsForSelected = algorithmColors[selectedAlgorithm] || { base: '#00ffff', comparing: '#ff0066' };
        
        // Update title with algorithm name
        document.title = `${selectedAlgorithm.replace(/([A-Z])/g, ' $1').trim()} Visualization`;
        document.querySelector('h1').textContent = `${selectedAlgorithm.replace(/([A-Z])/g, ' $1').trim()} Visualization`;
        
    // Set the algorithm color as a CSS variable (safe)
    document.documentElement.style.setProperty('--algorithm-color', colorsForSelected.base);

        const canvas = document.getElementById('visualizerCanvas');
        const ctx = canvas.getContext('2d');
    const speedSelect = document.getElementById('speed-select');
    const exampleDataBtn = document.getElementById('exampleDataBtn');
    const speedRange = document.getElementById('speed-range');
        const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const customSpeedBtn = document.getElementById('customSpeedBtn');
    const rightSpeedContainer = document.getElementById('rightSpeedContainer');
        const pseudocodeEl = document.getElementById('pseudocode');
        const messageEl = document.getElementById('message');
    let isPaused = false;
    const searchCanvasEl = document.getElementById('searchCanvas');
    const targetInputEl = document.getElementById('target-input');

        const NUM_BARS = 50;
        const BAR_WIDTH = canvas.width / NUM_BARS;
        let data = [];
        let originalValues = [];
        let isSorting = false;
        let stopSorting = false;
        
        const exampleData = [45, 12, 67, 34, 98, 21, 56, 78, 10, 89, 43, 29, 72, 5, 84, 61, 38, 93, 15, 76];
        let useExampleData = false;

        const pseudocodes = {
            bubbleSort: `for i = 0 to n-1
  for j = 0 to n-i-2
    if array[j] > array[j+1]
      swap(array[j], array[j+1])`,
            insertionSort: `for i = 1 to n-1
  key = array[i]
  j = i - 1
  while j >= 0 and array[j] > key
    array[j+1] = array[j]
    j = j - 1
  array[j+1] = key`,
            selectionSort: `for i = 0 to n-1
  minIndex = i
  for j = i+1 to n-1
    if array[j] < array[minIndex]
      minIndex = j
  swap(array[i], array[minIndex])`,
            quickSort: `quickSort(array, low, high):
  if low < high:
    pivot = partition(array, low, high)
    quickSort(array, low, pivot-1)
    quickSort(array, pivot+1, high)

partition(array, low, high):
  pivot = array[high]
  i = low - 1
  for j = low to high-1:
    if array[j] <= pivot:
      i++
      swap(array[i], array[j])
  swap(array[i+1], array[high])
  return i+1`,
            mergeSort: `mergeSort(array, left, right):
  if left < right:
    mid = (left + right) / 2
    mergeSort(array, left, mid)
    mergeSort(array, mid+1, right)
    merge(array, left, mid, right)

merge(array, left, mid, right):
  copy left and right halves to temp arrays
  merge back into main array in sorted order`,
            linearSearch: `linearSearch(array, target):
    for i = 0 to n-1:
        if array[i] == target:
            return i
    return -1`,
            binarySearch: `binarySearch(array, target):
    left = 0
    right = n - 1
    while left <= right:
        mid = (left + right) / 2
        if array[mid] == target:
            return mid
        else if array[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1`,
            insertMethod: `insertMethod(array, value):
    position = array.length
    for i = 0 to array.length-1:
        if value <= array[i]:
            position = i
            break
    insert value at position
    return position`,
            deleteMethod: `deleteMethod(array, value):
    for i = 0 to array.length-1:
        if array[i] == value:
            remove element at index i
            return i
    return -1`,
            dfs: `dfs(grid, start, end):
    stack = [start]
    visited = set()
    cameFrom = map()
    
    while stack not empty:
        current = stack.pop()
        if current == end:
            return reconstructPath(cameFrom, end)
        
        for neighbor in getNeighbors(current):
            if neighbor not in visited:
                visited.add(neighbor)
                cameFrom[neighbor] = current
                stack.push(neighbor)
    
    return no path found`,
            bfs: `bfs(grid, start, end):
    queue = [start]
    visited = set()
    cameFrom = map()
    
    while queue not empty:
        current = queue.shift()
        if current == end:
            return reconstructPath(cameFrom, end)
        
        for neighbor in getNeighbors(current):
            if neighbor not in visited:
                visited.add(neighbor)
                cameFrom[neighbor] = current
                queue.push(neighbor)
    
    return no path found`,
            treeDfs: `treeDfs(node):
    if node is null:
        return
    
    visit(node)
    treeDfs(node.left)
    treeDfs(node.right)`,
            treeBfs: `treeBfs(root):
    queue = [root]
    
    while queue not empty:
        node = queue.shift()
        visit(node)
        
        if node.left:
            queue.push(node.left)
        if node.right:
            queue.push(node.right)`
        };

        // Utility to update current data readout and internal arrays
        const dataInput = document.getElementById('data-input');
        const setDataBtn = document.getElementById('setDataBtn');
        const currentDataEl = document.getElementById('currentData');

        function updateCurrentDataReadout() {
            if (!currentDataEl) return;
            if (!originalValues || originalValues.length === 0) {
                currentDataEl.textContent = 'No data set yet.';
            } else {
                currentDataEl.textContent = originalValues.join(', ');
            }
        }

        function setDataFromInput() {
            const text = dataInput.value.trim();
            if (!text) return;
            // parse numbers separated by space/comma
            const arr = text.split(/[ ,]+/).map(s => parseFloat(s)).filter(n => !isNaN(n));
            if (arr.length === 0) return;
            originalValues = arr.slice();
            // scale to canvas for bar heights
            const maxVal = Math.max(...originalValues);
            data = originalValues.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
            drawBars();
            if (searchAlgos.has(selectedAlgorithm)) drawSearchCanvas({});
            updateCurrentDataReadout();
        }

        if (setDataBtn) setDataBtn.addEventListener('click', setDataFromInput);
        updateCurrentDataReadout();

    // Sync top and right speed selectors (two-way)
    // keep range in sync with top select
    if (speedSelect) {
        speedSelect.addEventListener('change', () => { if (speedRange) speedRange.value = speedSelect.value; });
    }

    // Sync range with selects and support custom range value
    function setCustomOptionIn(selectEl, val) {
        // Remove any existing custom option first
        const existing = selectEl.querySelector('option#customSpeedOption');
        if (existing) existing.remove();
        // If val matches a standard option, just set and return
        if (['1','250','1000'].includes(String(val))) {
            selectEl.value = String(val);
            return;
        }
        const opt = document.createElement('option');
        opt.id = 'customSpeedOption';
        opt.value = String(val);
        opt.textContent = `Custom (${val}ms)`;
        selectEl.appendChild(opt);
        selectEl.value = String(val);
    }

    if (speedRange) {
        // initialize range from main select
        if (speedSelect) speedRange.value = speedSelect.value;

        // when range changes, set top select (with custom option if needed)
        speedRange.addEventListener('input', () => {
            const v = String(speedRange.value);
            if (speedSelect) setCustomOptionIn(speedSelect, v);
            // update visible ms label if present
            const lbl = document.getElementById('speed-range-value'); if (lbl) lbl.textContent = v;
        });

        // when top select changes, update range and label
        if (speedSelect) speedSelect.addEventListener('change', () => { speedRange.value = speedSelect.value; const lbl = document.getElementById('speed-range-value'); if (lbl) lbl.textContent = speedSelect.value; });
    }

    // Custom button toggles right-side speed controls
    if (customSpeedBtn && rightSpeedContainer) {
        customSpeedBtn.addEventListener('click', () => {
            const isHidden = rightSpeedContainer.style.display === 'none' || !rightSpeedContainer.style.display;
            rightSpeedContainer.style.display = isHidden ? 'flex' : 'none';
            if (isHidden) {
                // when showing, sync values
                if (speedSelect) speedRange.value = speedSelect.value;
                const lbl = document.getElementById('speed-range-value'); if (lbl) lbl.textContent = speedRange.value;
                // focus the range for quick adjustment
                setTimeout(() => { if (speedRange) speedRange.focus(); }, 60);
            }
        });
    }

    // Show search UI elements only for search and data manipulation algorithms
    const searchAlgos = new Set(['linearSearch','binarySearch','insertMethod','deleteMethod']);
    const pathfindingAlgos = new Set([]);
    const treeAlgos = new Set(['treeDfs','treeBfs']);
    const gridCanvasEl = document.getElementById('gridCanvas');
    const treeCanvasEl = document.getElementById('treeCanvas');
    
    if (searchCanvasEl) searchCanvasEl.style.display = searchAlgos.has(selectedAlgorithm) ? '' : 'none';
    if (targetInputEl) targetInputEl.style.display = searchAlgos.has(selectedAlgorithm) ? '' : 'none';
    if (gridCanvasEl) gridCanvasEl.style.display = pathfindingAlgos.has(selectedAlgorithm) ? '' : 'none';
    if (treeCanvasEl) treeCanvasEl.style.display = treeAlgos.has(selectedAlgorithm) ? '' : 'none';

        function drawBars(bar1 = -1, bar2 = -1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const currentNumBars = data.length;
            const currentBarWidth = canvas.width / currentNumBars;
            const colors = algorithmColors[selectedAlgorithm];
            
            for (let k = 0; k < currentNumBars; k++) {
                let color = colors.base;
                if (k === bar1 || k === bar2) {
                    color = colors.comparing;
                }
                ctx.fillStyle = color;
                ctx.fillRect(k * currentBarWidth, canvas.height - data[k], currentBarWidth - 2, data[k]);

                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Segoe UI';
                ctx.textAlign = 'center';
                const numberText = originalValues[k].toString();
                const xPos = k * currentBarWidth + currentBarWidth / 2;
                const yPos = canvas.height - data[k] - 5;
                ctx.fillText(numberText, xPos, yPos);
            }
        }

        // Draw compact search visualization (indices, highlights)
        const searchCanvas = document.getElementById('searchCanvas');
        const sCtx = searchCanvas ? searchCanvas.getContext('2d') : null;
        function drawSearchCanvas(highlight = {}){
            if (!sCtx) return;
            const arr = originalValues.slice(0, 30); // show up to first 30 elements for clarity
            const w = searchCanvas.width;
            const h = searchCanvas.height;
            sCtx.clearRect(0,0,w,h);
            const cols = arr.length;
            const cellW = Math.max(20, Math.floor(w / cols));
            const pad = 6;
            sCtx.font = '12px Segoe UI';
            sCtx.textAlign = 'center';

            for (let i=0;i<cols;i++){
                const x = i*cellW + cellW/2;
                const y = h/2;
                // background
                let bg = 'rgba(255,255,255,0.03)';
                if (i === highlight.mid) bg = 'rgba(0,200,255,0.18)';
                if (i === highlight.left) bg = 'rgba(0,255,100,0.14)';
                if (i === highlight.right) bg = 'rgba(255,100,0,0.14)';
                if (i === highlight.checked) bg = 'rgba(255,45,149,0.18)';
                sCtx.fillStyle = bg;
                sCtx.fillRect(i*cellW+pad/2, 6, cellW-pad, h-12);

                // value
                sCtx.fillStyle = '#e0e0e0';
                sCtx.fillText(String(arr[i]), x, y);
            }
            // draw legends
            sCtx.fillStyle = '#8ff'; sCtx.fillText('mid', w - 120, 14);
        }

        // Grid-based path finding visualization
        const gridCanvas = document.getElementById('gridCanvas');
        const gCtx = gridCanvas ? gridCanvas.getContext('2d') : null;
        
        // Grid configuration
        const GRID_SIZE = 20;
        const COLS = Math.floor(gridCanvas.width / GRID_SIZE);
        const ROWS = Math.floor(gridCanvas.height / GRID_SIZE);
        
        // Grid states
        const GRID_STATES = {
            EMPTY: 0,
            WALL: 1,
            START: 2,
            END: 3,
            VISITED: 4,
            PATH: 5,
            CURRENT: 6
        };
        
        let grid = [];
        let startPos = { row: 2, col: 2 };
        let endPos = { row: ROWS - 3, col: COLS - 3 };
        let currentPath = [];
        let visitedCells = [];
        
        function initializeGrid() {
            grid = [];
            for (let row = 0; row < ROWS; row++) {
                grid[row] = [];
                for (let col = 0; col < COLS; col++) {
                    // Create walls around the border
                    if (row === 0 || row === ROWS - 1 || col === 0 || col === COLS - 1) {
                        grid[row][col] = GRID_STATES.WALL;
                    } else {
                        grid[row][col] = GRID_STATES.EMPTY;
                    }
                }
            }
            
            // Set start and end positions
            grid[startPos.row][startPos.col] = GRID_STATES.START;
            grid[endPos.row][endPos.col] = GRID_STATES.END;
            
            // Add some random obstacles
            for (let i = 0; i < 30; i++) {
                const row = Math.floor(Math.random() * (ROWS - 2)) + 1;
                const col = Math.floor(Math.random() * (COLS - 2)) + 1;
                if (grid[row][col] === GRID_STATES.EMPTY) {
                    grid[row][col] = GRID_STATES.WALL;
                }
            }
            
            drawGrid();
        }
        
        function drawGrid() {
            if (!gCtx) return;
            
            gCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const x = col * GRID_SIZE;
                    const y = row * GRID_SIZE;
                    
                    switch (grid[row][col]) {
                        case GRID_STATES.EMPTY:
                            gCtx.fillStyle = '#2a2a2a';
                            break;
                        case GRID_STATES.WALL:
                            gCtx.fillStyle = '#444444';
                            break;
                        case GRID_STATES.START:
                            gCtx.fillStyle = '#4CAF50';
                            break;
                        case GRID_STATES.END:
                            gCtx.fillStyle = '#F44336';
                            break;
                        case GRID_STATES.VISITED:
                            gCtx.fillStyle = '#2196F3';
                            break;
                        case GRID_STATES.PATH:
                            gCtx.fillStyle = '#FF9800';
                            break;
                        case GRID_STATES.CURRENT:
                            gCtx.fillStyle = '#FFEB3B';
                            break;
                    }
                    
                    gCtx.fillRect(x, y, GRID_SIZE - 1, GRID_SIZE - 1);
                    
                    // Draw grid lines
                    gCtx.strokeStyle = '#1a1a1a';
                    gCtx.lineWidth = 1;
                    gCtx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                }
            }
        }
        
        function getNeighbors(row, col) {
            const neighbors = [];
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right
            ];
            
            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < ROWS && 
                    newCol >= 0 && newCol < COLS && 
                    grid[newRow][newCol] !== GRID_STATES.WALL) {
                    neighbors.push({ row: newRow, col: newCol });
                }
            }
            
            return neighbors;
        }
        
        function reconstructPath(cameFrom, current) {
            const path = [current];
            while (cameFrom.has(`${current.row},${current.col}`)) {
                current = cameFrom.get(`${current.row},${current.col}`);
                path.unshift(current);
            }
            return path;
        }

        // DFS Path Finding Algorithm has been removed

        // BFS Path Finding Algorithm has been removed

        // Tree-based traversal algorithms
        const treeCanvas = document.getElementById('treeCanvas');
        const tCtx = treeCanvas ? treeCanvas.getContext('2d') : null;
        
        // Tree structure
        let tree = null;
        let visitedNodes = new Set();
        let currentNode = null;
        let traversalOrder = [];
        
        // Tree node class
        class TreeNode {
            constructor(value, x, y) {
                this.value = value;
                this.x = x;
                this.y = y;
                this.left = null;
                this.right = null;
                this.visited = false;
                this.current = false;
                this.radius = 25;
            }
        }
        
        function createTree() {
            // Create a binary tree with 3 levels (like in the image)
            tree = new TreeNode(0, 400, 80); // Root at center top
            
            // Level 1: Children of root
            tree.left = new TreeNode(1, 250, 180);
            tree.right = new TreeNode(2, 550, 180);
            
            // Level 2: Children of level 1
            tree.left.left = new TreeNode(3, 150, 280);
            tree.left.right = new TreeNode(4, 350, 280);
            tree.right.left = new TreeNode(5, 450, 280);
            tree.right.right = new TreeNode(6, 650, 280);
            
            // Level 3: Children of level 2 (some are leaves)
            tree.left.left.left = new TreeNode(7, 100, 380);
            tree.left.left.right = new TreeNode(8, 200, 380);
            tree.left.right.left = new TreeNode(9, 300, 380);
            tree.left.right.right = new TreeNode(10, 400, 380);
            // Nodes 5 and 6 are leaves (no children)
            
            drawTree();
        }
        
        function drawTree() {
            if (!tCtx) return;
            
            tCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);
            
            // Draw title
            tCtx.fillStyle = '#9C27B0';
            tCtx.font = 'bold 18px Segoe UI';
            tCtx.textAlign = 'center';
            tCtx.fillText('Tree Traversal Visualization', treeCanvas.width / 2, 30);
            
            // Draw tree recursively
            drawTreeNode(tree);
            
            // Draw traversal order
            drawTraversalOrder();
        }
        
        function drawTreeNode(node) {
            if (!node) return;
            
            // Draw connections to children first (so they appear behind nodes)
            if (node.left) {
                tCtx.strokeStyle = '#666666';
                tCtx.lineWidth = 2;
                tCtx.beginPath();
                tCtx.moveTo(node.x, node.y + node.radius);
                tCtx.lineTo(node.left.x, node.left.y - node.left.radius);
                tCtx.stroke();
                drawTreeNode(node.left);
            }
            
            if (node.right) {
                tCtx.strokeStyle = '#666666';
                tCtx.lineWidth = 2;
                tCtx.beginPath();
                tCtx.moveTo(node.x, node.y + node.radius);
                tCtx.lineTo(node.right.x, node.right.y - node.right.radius);
                tCtx.stroke();
                drawTreeNode(node.right);
            }
            
            // Draw node
            let nodeColor = '#4A148C'; // Default purple
            if (node.visited) {
                nodeColor = '#2196F3'; // Blue for visited
            }
            if (node.current) {
                nodeColor = '#FF9800'; // Orange for current
            }
            
            // Node circle
            tCtx.fillStyle = nodeColor;
            tCtx.beginPath();
            tCtx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
            tCtx.fill();
            
            // Node border
            tCtx.strokeStyle = '#FFFFFF';
            tCtx.lineWidth = 2;
            tCtx.stroke();
            
            // Node value
            tCtx.fillStyle = '#FFFFFF';
            tCtx.font = 'bold 16px Segoe UI';
            tCtx.textAlign = 'center';
            tCtx.fillText(node.value.toString(), node.x, node.y + 6);
        }
        
        function drawTraversalOrder() {
            if (traversalOrder.length === 0) return;
            
            tCtx.fillStyle = '#E0E0E0';
            tCtx.font = '14px Segoe UI';
            tCtx.textAlign = 'left';
            
            let orderText = 'Traversal Order: ';
            for (let i = 0; i < traversalOrder.length; i++) {
                orderText += traversalOrder[i];
                if (i < traversalOrder.length - 1) {
                    orderText += ' ‚Üí ';
                }
            }
            
            tCtx.fillText(orderText, 20, treeCanvas.height - 20);
        }
        
        function resetTree() {
            visitedNodes.clear();
            currentNode = null;
            traversalOrder = [];
            resetTreeNode(tree);
            drawTree();
        }
        
        function resetTreeNode(node) {
            if (!node) return;
            node.visited = false;
            node.current = false;
            resetTreeNode(node.left);
            resetTreeNode(node.right);
        }
        
        // Tree DFS Algorithm
        async function treeDfsTraversal() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            
            updateMessage(`üå≥ Starting Tree DFS traversal...`);
            await pause();
            
            resetTree();
            traversalOrder = [];
            
            await dfsTraverse(tree);
            
            updateMessage(`üéâ Tree DFS completed! Traversal order: ${traversalOrder.join(' ‚Üí ')}`);
            
            isSorting = false;
            stopBtn.disabled = true;
        }
        
        async function dfsTraverse(node) {
            if (!node || stopSorting) return;
            
            // Mark current node as being explored
            node.current = true;
            currentNode = node;
            drawTree();
            
            updateMessage(`üîç DFS visiting node ${node.value}...`);
            await pause();
            
            // Mark as visited and add to traversal order
            node.visited = true;
            node.current = false;
            visitedNodes.add(node.value);
            traversalOrder.push(node.value);
            drawTree();
            
            updateMessage(`‚úÖ Node ${node.value} visited. Traversal order: ${traversalOrder.join(' ‚Üí ')}`);
            await pause();
            
            // Recursively traverse left subtree
            if (node.left && !stopSorting) {
                updateMessage(`‚¨ÖÔ∏è Going to left child of ${node.value}...`);
                await pause();
                await dfsTraverse(node.left);
            }
            
            // Recursively traverse right subtree
            if (node.right && !stopSorting) {
                updateMessage(`‚û°Ô∏è Going to right child of ${node.value}...`);
                await pause();
                await dfsTraverse(node.right);
            }
            
            if (!stopSorting) {
                updateMessage(`üîô Backtracking from node ${node.value}...`);
                await pause();
            }
        }
        
        // Tree BFS Algorithm
        async function treeBfsTraversal() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            
            updateMessage(`üå≥ Starting Tree BFS traversal...`);
            await pause();
            
            resetTree();
            traversalOrder = [];
            
            const queue = [tree];
            
            while (queue.length > 0 && !stopSorting) {
                const node = queue.shift(); // FIFO - First In, First Out
                
                // Mark current node as being explored
                node.current = true;
                currentNode = node;
                drawTree();
                
                updateMessage(`üîç BFS visiting node ${node.value}...`);
                await pause();
                
                // Mark as visited and add to traversal order
                node.visited = true;
                node.current = false;
                visitedNodes.add(node.value);
                traversalOrder.push(node.value);
                drawTree();
                
                updateMessage(`‚úÖ Node ${node.value} visited. Traversal order: ${traversalOrder.join(' ‚Üí ')}`);
                await pause();
                
                // Add children to queue (left to right)
                if (node.left) {
                    queue.push(node.left);
                }
                if (node.right) {
                    queue.push(node.right);
                }
                
                if (queue.length > 0 && !stopSorting) {
                    updateMessage(`üìã Queue: [${queue.map(n => n.value).join(', ')}]`);
                    await pause();
                }
            }
            
            updateMessage(`üéâ Tree BFS completed! Traversal order: ${traversalOrder.join(' ‚Üí ')}`);
            
            isSorting = false;
            stopBtn.disabled = true;
        }

        function initializeData() {
            if (pathfindingAlgos.has(selectedAlgorithm)) {
                // Initialize grid for pathfinding algorithms
                initializeGrid();
                isSorting = false;
                startBtn.disabled = false;
                updatePseudocode();
                messageEl.textContent = 'Ready to find path. Press Start.';
            } else if (treeAlgos.has(selectedAlgorithm)) {
                // Initialize tree for tree traversal algorithms
                createTree();
                isSorting = false;
                startBtn.disabled = false;
                updatePseudocode();
                messageEl.textContent = 'Ready to traverse tree. Press Start.';
            } else {
                if (useExampleData) {
                    originalValues = [...exampleData];
                    const maxVal = Math.max(...exampleData);
                    data = exampleData.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
                } else {
                    originalValues = [];
                    data = [];
                    for (let k = 0; k < NUM_BARS; k++) {
                        const value = Math.floor(Math.random() * 350) + 10;
                        originalValues.push(value);
                        data.push(value);
                    }
                }
                isSorting = false;
                startBtn.disabled = false;
                drawBars();
                if (searchAlgos.has(selectedAlgorithm)) drawSearchCanvas({});
                updatePseudocode();
                messageEl.textContent = 'Ready to visualize. Press Start.';
            }
        }

        async function pause() {
            const speed = parseInt(speedSelect.value, 10);
            // wait in small increments so pause can be toggled responsively
            const step = Math.max(20, Math.floor(speed / 8));
            let waited = 0;
            while (waited < speed) {
                if (stopSorting) break;
                while (isPaused) {
                    // while paused, surface the last condition into the message box
                    try {
                        if (messageEl) {
                            messageEl.textContent = lastConditionDetail || 'Paused ‚Äî waiting at current check...';
                        }
                    } catch (e) {
                        // ignore
                    }
                    await new Promise(r => setTimeout(r, 150));
                    if (stopSorting) break;
                }
                await new Promise(r => setTimeout(r, step));
                waited += step;
            }
        }

        function updateMessage(text) {
            messageEl.textContent = text;
        }

        function updatePseudocode() {
            pseudocodeEl.textContent = pseudocodes[selectedAlgorithm];
        }

        async function bubbleSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            const currentNumBars = data.length;
            
            for (let i = 0; i < currentNumBars && !stopSorting; i++) {
                updateMessage(`Outer loop: Pass ${i + 1}/${currentNumBars}.`);
                await pause();
                for (let j = 0; j < currentNumBars - i - 1 && !stopSorting; j++) {
                    drawBars(j, j + 1);
                    const cond = originalValues[j] > originalValues[j + 1];
                    lastConditionDetail = `Comparing index ${j} (${originalValues[j]}) > index ${j+1} (${originalValues[j+1]}) ? ${cond ? 'true' : 'false'}`;
                    updateMessage(`Comparing elements at index ${j} (${originalValues[j]}) and ${j + 1} (${originalValues[j + 1]}). Condition (a > b): ${cond ? 'true' : 'false'}.`);
                    await pause();
                    
                    if (data[j] > data[j + 1]) {
                        [data[j], data[j + 1]] = [data[j + 1], data[j]];
                        [originalValues[j], originalValues[j + 1]] = [originalValues[j + 1], originalValues[j]];
                        drawBars(j, j + 1);
                        updateMessage(`Swapping elements at index ${j} and ${j + 1}.`);
                        await pause();
                    }
                }
            }
            
            isSorting = false;
            stopBtn.disabled = true;
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
        }

        async function insertionSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            const currentNumBars = data.length;
            
            for (let i = 1; i < currentNumBars && !stopSorting; i++) {
                let current = data[i];
                let currentVal = originalValues[i];
                let j = i - 1;
                updateMessage(`Taking element at index ${i} (${currentVal}) as key.`);
                await pause();
                
                while (j >= 0 && data[j] > current && !stopSorting) {
                    const cond = originalValues[j] > currentVal;
                    lastConditionDetail = `Is index ${j} value ${originalValues[j]} > key ${currentVal}? ${cond ? 'true' : 'false'}`;
                    data[j + 1] = data[j];
                    originalValues[j + 1] = originalValues[j];
                    j = j - 1;
                    drawBars(j + 1, i);
                    updateMessage(`Condition (a > key) is ${cond ? 'true' : 'false'} ‚Äî shifting element at index ${j + 1} to the right.`);
                    await pause();
                }
                data[j + 1] = current;
                originalValues[j + 1] = currentVal;
                drawBars(i, j + 1);
                await pause();
            }
            
            isSorting = false;
            stopBtn.disabled = true;
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
        }

        async function selectionSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            const currentNumBars = data.length;
            
            for (let i = 0; i < currentNumBars && !stopSorting; i++) {
                let minIndex = i;
                updateMessage(`Finding minimum element from index ${i} to ${currentNumBars-1}`);
                await pause();
                
                for (let j = i + 1; j < currentNumBars && !stopSorting; j++) {
                    drawBars(minIndex, j);
                    const cond = originalValues[j] < originalValues[minIndex];
                    lastConditionDetail = `Is index ${j} value ${originalValues[j]} < current min index ${minIndex} value ${originalValues[minIndex]}? ${cond ? 'true' : 'false'}`;
                    updateMessage(`Comparing ${originalValues[j]} with current minimum ${originalValues[minIndex]}. Condition (a < min): ${cond ? 'true' : 'false'}.`);
                    await pause();
                    
                    if (data[j] < data[minIndex]) {
                        minIndex = j;
                        drawBars(minIndex, j);
                        updateMessage(`New minimum found: ${originalValues[minIndex]}`);
                        await pause();
                    }
                }
                
                if (minIndex !== i) {
                    [data[i], data[minIndex]] = [data[minIndex], data[i]];
                    [originalValues[i], originalValues[minIndex]] = [originalValues[minIndex], originalValues[i]];
                    drawBars(i, minIndex);
                    updateMessage(`Swapping ${originalValues[i]} to position ${i}`);
                    await pause();
                }
            }
            
            isSorting = false;
            stopBtn.disabled = true;
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
        }

        async function quickSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;

            async function partition(low, high) {
                const pivot = data[high];
                const pivotVal = originalValues[high];
                let i = low - 1;
                
                updateMessage(`Partitioning around pivot ${pivotVal}`);
                await pause();
                
                for (let j = low; j < high && !stopSorting; j++) {
                    drawBars(j, high);
                    const cond = originalValues[j] <= pivotVal;
                    lastConditionDetail = `Is index ${j} value ${originalValues[j]} <= pivot ${pivotVal}? ${cond ? 'true' : 'false'}`;
                    updateMessage(`Comparing ${originalValues[j]} with pivot ${pivotVal}. Condition (a <= pivot): ${cond ? 'true' : 'false'}.`);
                    await pause();
                    
                    if (data[j] <= pivot) {
                        i++;
                        [data[i], data[j]] = [data[j], data[i]];
                        [originalValues[i], originalValues[j]] = [originalValues[j], originalValues[i]];
                        drawBars(i, j);
                        updateMessage(`Swapping elements: ${originalValues[i]} and ${originalValues[j]}`);
                        await pause();
                    }
                }
                
                [data[i + 1], data[high]] = [data[high], data[i + 1]];
                [originalValues[i + 1], originalValues[high]] = [originalValues[high], originalValues[i + 1]];
                drawBars(i + 1, high);
                await pause();
                
                return i + 1;
            }

            async function quickSortRecursive(low, high) {
                if (low < high && !stopSorting) {
                    const pi = await partition(low, high);
                    await quickSortRecursive(low, pi - 1);
                    await quickSortRecursive(pi + 1, high);
                }
            }

            await quickSortRecursive(0, data.length - 1);
            
            isSorting = false;
            stopBtn.disabled = true;
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
        }

        async function mergeSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;

            async function merge(left, mid, right) {
                const leftArray = data.slice(left, mid + 1);
                const rightArray = data.slice(mid + 1, right + 1);
                const leftOriginal = originalValues.slice(left, mid + 1);
                const rightOriginal = originalValues.slice(mid + 1, right + 1);
                
                let i = 0, j = 0, k = left;
                
                while (i < leftArray.length && j < rightArray.length && !stopSorting) {
                    drawBars(left + i, mid + 1 + j);
                    const cond = leftOriginal[i] <= rightOriginal[j];
                    lastConditionDetail = `Compare left ${leftOriginal[i]} <= right ${rightOriginal[j]} ? ${cond ? 'true' : 'false'}`;
                    updateMessage(`Comparing ${leftOriginal[i]} with ${rightOriginal[j]}. Condition (left <= right): ${cond ? 'true' : 'false'}.`);
                    await pause();
                    
                    if (leftArray[i] <= rightArray[j]) {
                        data[k] = leftArray[i];
                        originalValues[k] = leftOriginal[i];
                        i++;
                    } else {
                        data[k] = rightArray[j];
                        originalValues[k] = rightOriginal[j];
                        j++;
                    }
                    drawBars(k);
                    await pause();
                    k++;
                }
                
                while (i < leftArray.length && !stopSorting) {
                    data[k] = leftArray[i];
                    originalValues[k] = leftOriginal[i];
                    drawBars(k);
                    await pause();
                    i++;
                    k++;
                }
                
                while (j < rightArray.length && !stopSorting) {
                    data[k] = rightArray[j];
                    originalValues[k] = rightOriginal[j];
                    drawBars(k);
                    await pause();
                    j++;
                    k++;
                }
            }

            async function mergeSortRecursive(left, right) {
                if (left < right && !stopSorting) {
                    const mid = Math.floor((left + right) / 2);
                    updateMessage(`Dividing array from index ${left} to ${right}`);
                    await pause();
                    
                    await mergeSortRecursive(left, mid);
                    await mergeSortRecursive(mid + 1, right);
                    await merge(left, mid, right);
                }
            }

            await mergeSortRecursive(0, data.length - 1);
            
            isSorting = false;
            stopBtn.disabled = true;
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
        }

        // Insert method algorithm with enhanced visualization
        async function insertMethod() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            
            const targetRaw = document.getElementById('target-input').value.trim();
            const target = parseInt(targetRaw, 10);
            if (isNaN(target)) {
                updateMessage('Please enter a numeric value to insert.');
                isSorting = false;
                stopBtn.disabled = true;
                return;
            }

            updateMessage(`üîç Searching for insertion position for value ${target}...`);
            await pause();

            // Find the correct position to insert (assuming sorted array)
            let insertPosition = originalValues.length;
            for (let i = 0; i < originalValues.length && !stopSorting; i++) {
                drawBars(i, -1);
                drawSearchCanvas({ checked: i });
                const cond = target <= originalValues[i];
                
                lastConditionDetail = `Check if ${target} <= ${originalValues[i]} at index ${i} ? ${cond ? 'true' : 'false'}`;
                updateMessage(`üîç Checking position ${i}: is ${target} <= ${originalValues[i]}? ${cond ? '‚úì Yes' : '‚úó No'}.`);
                await pause();
                
                if (cond) {
                    insertPosition = i;
                    updateMessage(`‚úÖ Found insertion position at index ${i}.`);
                    await pause();
                    break;
                }
            }

            // Show insertion process with animation
            updateMessage(`üì• Inserting value ${target} at position ${insertPosition}...`);
            await pause();

            // Create a visual effect for insertion
            for (let i = originalValues.length; i > insertPosition; i--) {
                drawBars(insertPosition, i);
                updateMessage(`‚¨ÖÔ∏è Shifting elements to make room for insertion...`);
                await pause();
            }

            // Insert the value
            originalValues.splice(insertPosition, 0, target);
            const maxVal = Math.max(...originalValues);
            data = originalValues.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
            
            // Highlight the inserted element
            drawBars(insertPosition, -1);
            drawSearchCanvas({ checked: insertPosition });
            updateMessage(`‚úÖ Value ${target} successfully inserted at position ${insertPosition}!`);
            await pause();

            isSorting = false;
            stopBtn.disabled = true;
            drawBars();
            updateMessage(`üéâ Insert operation completed! Array now has ${originalValues.length} elements.`);
        }

        // Delete method algorithm with enhanced visualization
        async function deleteMethod() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            
            const targetRaw = document.getElementById('target-input').value.trim();
            const target = parseInt(targetRaw, 10);
            if (isNaN(target)) {
                updateMessage('Please enter a numeric value to delete.');
                isSorting = false;
                stopBtn.disabled = true;
                return;
            }

            updateMessage(`üîç Searching for value ${target} to delete...`);
            await pause();

            let deleteIndex = -1;
            for (let i = 0; i < originalValues.length && !stopSorting; i++) {
                drawBars(i, -1);
                drawSearchCanvas({ checked: i });
                const cond = originalValues[i] === target;
                
                lastConditionDetail = `Check index ${i} value ${originalValues[i]} === target ${target} ? ${cond ? 'true' : 'false'}`;
                updateMessage(`üîç Checking index ${i}: value ${originalValues[i]}. Equals target? ${cond ? '‚úÖ Yes' : '‚ùå No'}.`);
                await pause();
                
                if (cond) {
                    deleteIndex = i;
                    updateMessage(`üéØ Found value ${target} at index ${i}!`);
                    await pause();
                    break;
                }
            }

            if (deleteIndex !== -1) {
                updateMessage(`üóëÔ∏è Deleting value ${target} from position ${deleteIndex}...`);
                await pause();

                // Show deletion process with animation
                drawBars(deleteIndex, -1);
                updateMessage(`‚¨ÖÔ∏è Removing element and shifting remaining elements...`);
                await pause();

                // Remove the element
                originalValues.splice(deleteIndex, 1);
                
                // Update visualization
                if (originalValues.length > 0) {
                    const maxVal = Math.max(...originalValues);
                    data = originalValues.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
                } else {
                    data = [];
                }
                
                drawBars();
                drawSearchCanvas({});
                updateMessage(`‚úÖ Value ${target} successfully deleted from position ${deleteIndex}!`);
                await pause();
                updateMessage(`üéâ Delete operation completed! Array now has ${originalValues.length} elements.`);
            } else {
                updateMessage(`‚ùå Value ${target} not found in the array.`);
                drawBars();
                drawSearchCanvas({});
            }
            
            isSorting = false;
            stopBtn.disabled = true;
        }

        // Search algorithm visualizers
        async function linearSearch() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            const targetRaw = document.getElementById('target-input').value.trim();
            const target = parseInt(targetRaw, 10);
            if (isNaN(target)) {
                updateMessage('Please enter a numeric target to search for.');
                isSorting = false;
                stopBtn.disabled = true;
                return;
            }

            for (let i = 0; i < originalValues.length && !stopSorting; i++) {
                drawBars(i, -1);
                drawSearchCanvas({ checked: i });
                const cond = originalValues[i] === target;
                lastConditionDetail = `Check index ${i} value ${originalValues[i]} === target ${target} ? ${cond ? 'true' : 'false'}`;
                updateMessage(`Checking index ${i}: value ${originalValues[i]}. Equals target? ${cond ? 'true' : 'false'}.`);
                await pause();
                if (cond) {
                    updateMessage(`Target found at index ${i}.`);
                    break;
                }
            }

            if (!stopSorting && !originalValues.includes(target)) updateMessage('Target not found in the array.');
            isSorting = false;
            stopBtn.disabled = true;
        }

        async function binarySearch() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            const targetRaw = document.getElementById('target-input').value.trim();
            const target = parseInt(targetRaw, 10);
            if (isNaN(target)) {
                updateMessage('Please enter a numeric target to search for.');
                isSorting = false;
                stopBtn.disabled = true;
                return;
            }

            // Ensure array is sorted
            originalValues.sort((a, b) => a - b);
            const maxVal = Math.max(...originalValues);
            data = originalValues.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
            drawBars();

            let left = 0;
            let right = originalValues.length - 1;
            while (left <= right && !stopSorting) {
                const mid = Math.floor((left + right) / 2);
                drawBars(mid, left);
                drawSearchCanvas({ left: left, mid: mid, right: right });
                const val = originalValues[mid];
                const eq = val === target;
                const lt = val < target;
                lastConditionDetail = `Mid index ${mid} value ${val} === target ${target}? ${eq ? 'true' : 'false'}; Less than target? ${lt ? 'true' : 'false'}`;
                updateMessage(`Left=${left}, Right=${right}, Mid=${mid} (value=${val}). Equal? ${eq ? 'true' : 'false'}, Less than target? ${lt ? 'true' : 'false'}.`);
                await pause();
                if (eq) {
                    updateMessage(`Target found at index ${mid}.`);
                    break;
                } else if (lt) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            if (!stopSorting && !originalValues.includes(target)) updateMessage('Target not found in the array.');
            isSorting = false;
            stopBtn.disabled = true;
        }

        startBtn.addEventListener('click', async () => {
            if (isSorting) return;
            
            startBtn.disabled = true;
            exampleDataBtn.disabled = true;
            pauseBtn.disabled = false;
            pauseBtn.textContent = 'Pause';
            isPaused = false;
            
            if (selectedAlgorithm === 'bubbleSort') {
                await bubbleSort();
            } else if (selectedAlgorithm === 'insertionSort') {
                await insertionSort();
            } else if (selectedAlgorithm === 'selectionSort') {
                await selectionSort();
            } else if (selectedAlgorithm === 'quickSort') {
                await quickSort();
            } else if (selectedAlgorithm === 'mergeSort') {
                await mergeSort();
            } else if (selectedAlgorithm === 'linearSearch') {
                await linearSearch();
            } else if (selectedAlgorithm === 'binarySearch') {
                await binarySearch();
            } else if (selectedAlgorithm === 'insertMethod') {
                await insertMethod();
            } else if (selectedAlgorithm === 'deleteMethod') {
                await deleteMethod();
            // DFS and BFS pathfinding algorithms have been removed
            } else if (selectedAlgorithm === 'treeDfs') {
                await treeDfsTraversal();
            } else if (selectedAlgorithm === 'treeBfs') {
                await treeBfsTraversal();
            } else {
                // Fallback to bubble sort if algorithm is not recognized
                await bubbleSort();
            }
            
            startBtn.disabled = false;
            exampleDataBtn.disabled = false;
            pauseBtn.disabled = true;
        });

        pauseBtn.addEventListener('click', ()=>{
            if (!isSorting) return;
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
            updateMessage(isPaused ? 'Paused' : 'Resuming...');
        });

        stopBtn.addEventListener('click', () => {
            if (isSorting) {
                stopSorting = true;
                updateMessage("Stopping the sorting process...");
                // reset pause state
                isPaused = false;
                if (pauseBtn) { pauseBtn.textContent = 'Pause'; pauseBtn.disabled = true; }
            }
        });

        exampleDataBtn.addEventListener('click', () => {
            if (!isSorting) {
                useExampleData = true;
                initializeData();
            }
        });

        window.onload = initializeData;

        // Explanation functions for sidebar buttons
        function showAlgorithmExplanation() {
            const explanations = {
                bubbleSort: "Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The algorithm gets its name from the way smaller elements 'bubble' to the top of the list.",
                insertionSort: "Insertion Sort builds the sorted array one item at a time by inserting each new element into its correct position among the already sorted elements. It works like sorting playing cards in your hand.",
                selectionSort: "Selection Sort divides the array into sorted and unsorted parts, repeatedly finding the smallest element from the unsorted part and moving it to the sorted part.",
                quickSort: "Quick Sort is a divide-and-conquer algorithm that picks a pivot element and partitions the array around it. It then recursively sorts the sub-arrays before and after the pivot.",
                mergeSort: "Merge Sort splits the array into halves, recursively sorts each half, and then merges the sorted halves back together using a stable merging process.",
                linearSearch: "Linear Search checks each element in the list one by one until it finds the target value or reaches the end. It's the simplest search algorithm.",
                binarySearch: "Binary Search works on sorted arrays by repeatedly dividing the search interval in half, comparing the middle element to the target, and narrowing the search range.",
                insertMethod: "Insert Method finds the correct position to insert a new value while maintaining the sorted order of the array. It searches for the appropriate position and inserts the element there.",
                deleteMethod: "Delete Method searches for a specific value in the array and removes it if found. It performs a linear search to locate the element and then removes it from the array.",
                dfs: "Depth-First Search (DFS) explores as far as possible along each branch before backtracking. It uses a stack (LIFO) and can find any path from start to end, though not necessarily the shortest.",
                bfs: "Breadth-First Search (BFS) explores all neighbors at the current depth before moving to the next level. It uses a queue (FIFO) and guarantees finding the shortest path in unweighted graphs.",
                treeDfs: "Tree DFS traverses a tree by going as deep as possible along each branch before backtracking. It visits nodes in pre-order: root, left subtree, right subtree.",
                treeBfs: "Tree BFS traverses a tree level by level, visiting all nodes at the current depth before moving to the next level. It guarantees visiting nodes in breadth-first order."
            };
            
            const explanation = explanations[selectedAlgorithm] || "No explanation available for this algorithm.";
            messageEl.innerHTML = `<strong>üìñ Algorithm Explanation:</strong><br><br>${explanation}`;
        }

        function showComplexityInfo() {
            const complexities = {
                bubbleSort: "Time: O(n¬≤) average/worst case, O(n) best case<br>Space: O(1)",
                insertionSort: "Time: O(n¬≤) average/worst case, O(n) best case<br>Space: O(1)",
                selectionSort: "Time: O(n¬≤) in all cases<br>Space: O(1)",
                quickSort: "Time: O(n log n) average case, O(n¬≤) worst case<br>Space: O(log n)",
                mergeSort: "Time: O(n log n) in all cases<br>Space: O(n)",
                linearSearch: "Time: O(n) average/worst case, O(1) best case<br>Space: O(1)",
                binarySearch: "Time: O(log n) in all cases<br>Space: O(1)",
                insertMethod: "Time: O(n) average/worst case, O(1) best case<br>Space: O(1)",
                deleteMethod: "Time: O(n) average/worst case, O(1) best case<br>Space: O(1)",
                // DFS and BFS complexity information removed
                treeDfs: "Time: O(n) where n=nodes in tree<br>Space: O(h) where h=tree height",
                treeBfs: "Time: O(n) where n=nodes in tree<br>Space: O(w) where w=max tree width"
            };
            
            const complexity = complexities[selectedAlgorithm] || "No complexity information available.";
            messageEl.innerHTML = `<strong>‚è±Ô∏è Time & Space Complexity:</strong><br><br>${complexity}`;
        }

        function showHowItWorks() {
            const howItWorks = {
                bubbleSort: "1. Compare adjacent elements<br>2. Swap if they're in wrong order<br>3. Repeat for each element<br>4. Continue until no swaps needed",
                insertionSort: "1. Take one element at a time<br>2. Compare with sorted elements<br>3. Insert in correct position<br>4. Shift elements as needed",
                selectionSort: "1. Find minimum in unsorted part<br>2. Swap with first unsorted element<br>3. Move boundary of sorted part<br>4. Repeat until sorted",
                quickSort: "1. Choose a pivot element<br>2. Partition array around pivot<br>3. Recursively sort sub-arrays<br>4. Combine results",
                mergeSort: "1. Divide array into halves<br>2. Recursively sort each half<br>3. Merge sorted halves<br>4. Continue until fully sorted",
                linearSearch: "1. Start from first element<br>2. Compare with target value<br>3. Move to next if not found<br>4. Return index when found",
                binarySearch: "1. Compare target with middle element<br>2. Eliminate half of search space<br>3. Repeat on remaining half<br>4. Continue until found or exhausted",
                insertMethod: "1. Search for insertion position<br>2. Compare with existing elements<br>3. Shift elements to make room<br>4. Insert new element",
                deleteMethod: "1. Search for target element<br>2. Locate element position<br>3. Remove element from array<br>4. Shift remaining elements",
                // DFS and BFS how-it-works information removed
                treeDfs: "1. Visit current node<br>2. Recursively traverse left subtree<br>3. Recursively traverse right subtree<br>4. Backtrack when done",
                treeBfs: "1. Start with root in queue<br>2. Process nodes level by level<br>3. Add children to queue<br>4. Continue until all levels visited"
            };
            
            const steps = howItWorks[selectedAlgorithm] || "No step-by-step information available.";
            messageEl.innerHTML = `<strong>üîß How It Works:</strong><br><br>${steps}`;
        }

        function showUseCases() {
            const useCases = {
                bubbleSort: "‚Ä¢ Educational purposes<br>‚Ä¢ Small datasets<br>‚Ä¢ Simple implementation<br>‚Ä¢ When stability is required",
                insertionSort: "‚Ä¢ Small datasets<br>‚Ä¢ Nearly sorted data<br>‚Ä¢ Hybrid sorting algorithms<br>‚Ä¢ Online sorting scenarios",
                selectionSort: "‚Ä¢ Memory-constrained environments<br>‚Ä¢ When write operations are expensive<br>‚Ä¢ Simple implementation needed<br>‚Ä¢ Small datasets",
                quickSort: "‚Ä¢ General-purpose sorting<br>‚Ä¢ Large datasets<br>‚Ä¢ In-place sorting<br>‚Ä¢ Average-case performance critical",
                mergeSort: "‚Ä¢ Stable sorting required<br>‚Ä¢ Large datasets<br>‚Ä¢ External sorting<br>‚Ä¢ Linked lists",
                linearSearch: "‚Ä¢ Unsorted data<br>‚Ä¢ Small datasets<br>‚Ä¢ Finding all occurrences<br>‚Ä¢ Simple implementation",
                binarySearch: "‚Ä¢ Sorted arrays<br>‚Ä¢ Large datasets<br>‚Ä¢ Database indexing<br>‚Ä¢ Efficient searching",
                insertMethod: "‚Ä¢ Dynamic data structures<br>‚Ä¢ Database systems<br>‚Ä¢ Priority queues<br>‚Ä¢ Maintaining sorted order",
                deleteMethod: "‚Ä¢ Dynamic data structures<br>‚Ä¢ Database management<br>‚Ä¢ Memory management<br>‚Ä¢ Array manipulation",
                // DFS and BFS use cases information removed
                treeDfs: "‚Ä¢ Expression tree evaluation<br>‚Ä¢ Directory traversal<br>‚Ä¢ Syntax tree parsing<br>‚Ä¢ Pre/in/post order traversal",
                treeBfs: "‚Ä¢ Level-order printing<br>‚Ä¢ Finding tree height<br>‚Ä¢ Level-wise processing<br>‚Ä¢ Breadth-first operations"
            };
            
            const cases = useCases[selectedAlgorithm] || "No use case information available.";
            messageEl.innerHTML = `<strong>üí° Use Cases:</strong><br><br>${cases}`;
        }
    </script>
</body>
</html>