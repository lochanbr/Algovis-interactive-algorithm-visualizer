<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Visualization</title>
    <style>
        :root {
            /* Dark theme colors (default) */
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #0d0d0d;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --text-accent: #00ffff;
            --border-primary: #00ffff;
            --border-secondary: #00b8c4;
            --shadow-primary: rgba(0, 255, 255, 0.1);
            --shadow-secondary: rgba(0, 255, 255, 0.3);
            --shadow-glow: rgba(0, 255, 255, 0.35);
            --button-bg: #222;
            --modal-bg: rgba(0, 0, 0, 0.8);
            --canvas-bg: #0d0d0d;
        }
        
        [data-theme="light"] {
            /* Light theme colors */
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #fafafa;
            --text-primary: #212121;
            --text-secondary: #666666;
            --text-accent: #1976d2;
            --border-primary: #1976d2;
            --border-secondary: #2196f3;
            --shadow-primary: rgba(25, 118, 210, 0.1);
            --shadow-secondary: rgba(25, 118, 210, 0.3);
            --shadow-glow: rgba(25, 118, 210, 0.35);
            --button-bg: #e3f2fd;
            --modal-bg: rgba(255, 255, 255, 0.95);
            --canvas-bg: #fafafa;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: var(--text-accent);
            font-size: 2.5em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: none;
            animation: none;
        }
        
        @keyframes intensiveGlow {
            0% { 
                text-shadow: 
                    0 0 5px #00ffff,
                    0 0 10px #00ffff,
                    0 0 20px #00ffff,
                    0 0 40px #00ffff,
                    0 0 80px #00ffff;
                transform: scale(1);
            }
            100% { 
                text-shadow: 
                    0 0 10px #00ffff,
                    0 0 20px #00ffff,
                    0 0 30px #00ffff,
                    0 0 60px #00ffff,
                    0 0 120px #00ffff,
                    0 0 160px #00ffff;
                transform: scale(1.05);
            }
        }
        .container {
            display: flex;
            width: 100%;
            max-width: 1400px;
            gap: 20px;
            margin-top: 20px;
            /* align items to the top so the info panel (pseudocode) sits higher */
            align-items: flex-start;
        }
        
        .explanation-sidebar {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: stretch;
        }
        
        .explanation-btn {
            padding: 12px 16px;
            border-radius: 8px;
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            border: none;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
            text-align: center;
        }
        
        .explanation-btn:hover {
            background: linear-gradient(135deg, #ff8c42, #ffa726);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
        }
        
        .explanation-btn:active {
            transform: translateY(0);
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid var(--algorithm-color, var(--border-primary));
            box-shadow: 0 0 10px var(--algorithm-color, var(--shadow-primary));
            background-color: var(--canvas-bg);
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }
        select, button {
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #00ffff;
            background-color: #2c2c2c;
            color: #e0e0e0;
            box-shadow: 0 0 5px #00ffff;
        }
        button {
            cursor: pointer;
            border: none;
            color: #121212;
            background-color: #00ffff;
            font-weight: bold;
            text-transform: uppercase;
        }
        button:hover {
            background-color: var(--button-bg);
            box-shadow: 0 0 10px var(--shadow-secondary);
        }
        button:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
        }
        .info-panel {
            width: 300px;
            background-color: var(--bg-secondary);
            border: 2px solid var(--border-primary);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 15px var(--shadow-primary);
        }
        .pseudocode-box, .message-box {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            box-shadow: 0 0 5px var(--shadow-primary);
            padding: 8px 10px;
            border-radius: 6px;
            white-space: pre-wrap;
            color: var(--text-primary);
            margin-bottom: 10px;
        }
        .pseudocode-box{
            /* Compact styling for pseudocode */
            overflow: hidden;
            display: block;
            padding: 8px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        .pseudocode-box h2 {
            margin: 0 0 8px 0;
            font-size: 1em;
            color: var(--text-accent);
            font-weight: 600;
        }
        .pseudocode-box pre{
            display: block;
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.3;
        }
        .code-line {
            padding: 1px 0;
            border-radius: 2px;
            transition: background-color 0.3s ease;
        }
        .code-line.current-step {
            background-color: var(--shadow-primary);
            border-left: 2px solid var(--text-accent);
            padding-left: 6px;
        }
        /* Highlight classes used by JS */
        .code-line.highlighted {
            background-color: var(--shadow-primary);
            border-left: 2px solid var(--text-accent);
            padding-left: 6px;
        }
        .code-line.executing {
            background-color: rgba(0, 200, 255, 0.18);
            border-left: 2px solid #00ffff;
            padding-left: 6px;
        }
        .message-box {
            /* let the explanation fit fully without scrolling */
            height: auto;
            max-height: none;
            overflow: visible;
        }
        .complexity-box {
            background-color: #0d0d0d;
            border: 2px solid #9C27B0;
            box-shadow: 0 0 8px #9C27B0;
            border-radius: 8px;
            padding: 12px;
            color: #e0e0e0;
            font-size: 13px;
            line-height: 1.4;
            display: block;
        }
        .complexity-box h2 {
            margin-top: 0;
            font-size: 1.2em;
            color: #9C27B0;
            border-bottom: 1px solid #9C27B0;
            padding-bottom: 6px;
        }
        .complexity-item {
            margin: 8px 0;
            display: flex;
            justify-content: flex-start;
        }
        .metrics-item {
            margin: 6px 0;
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            background-color: #1a1a1a;
            border-radius: 4px;
            border-left: 3px solid #9C27B0;
        }
        .metrics-label {
            font-weight: 600;
            color: #e0e0e0;
        }
        .metrics-value {
            font-family: monospace;
            color: #00ffff;
            font-weight: bold;
            align-items: center;
            gap: 12px;
        }
        .complexity-label {
            font-weight: 500;
            min-width: 80px;
        }
        .complexity-value {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            cursor: help;
        }
        .complexity-good { background: #1B5E20; color: #4CAF50; }
        .complexity-moderate { background: #E65100; color: #FF9800; }
        .complexity-poor { background: #B71C1C; color: #F44336; }
        .complexity-tooltip {
            position: relative;
        }
        .complexity-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #fff;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .logo {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            z-index: 1000;
            opacity: 0.9;
            transition: opacity 0.3s ease;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: none;
            border: 2px solid rgba(0,255,255,0.65);
            filter: contrast(1.22) saturate(1.15) brightness(1.06);
            background-color: transparent;
        }
        .logo:hover {
            opacity: 1;
        }
        @keyframes logoGlow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(0,255,255,0.35), 0 0 18px rgba(0,255,255,0.2);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 18px rgba(0,255,255,0.55), 0 0 32px rgba(0,255,255,0.35);
                transform: scale(1.03);
            }
        }
        .pseudocode-box:hover{
            box-shadow: 0 0 8px var(--shadow-secondary);
            border: 1px solid var(--text-accent);
        }

        /* Live Code Highlighting Styles - merged with above */
        
        .code-line.highlighted {
            background-color: rgba(0, 255, 255, 0.2);
            border-left: 4px solid #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
            animation: codeGlow 0.6s ease-in-out;
        }
        
        .code-line.executing {
            background-color: rgba(255, 165, 0, 0.3);
            border-left: 4px solid #ffa500;
            box-shadow: 0 0 15px rgba(255, 165, 0, 0.6);
        }
        
        @keyframes codeGlow {
            0% { 
                background-color: rgba(0, 255, 255, 0.4);
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            }
            100% { 
                background-color: rgba(0, 255, 255, 0.2);
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
            }
        }
        .info-panel h2 {
            margin-top: 0;
            font-size: 1.2em;
            color: #00ffff;
            border-bottom: 1px solid #00ffff;
            padding-bottom: 5px;
        }
        .back-button {
            margin-bottom: 20px;
        }

        /* Use standard system cursors */
        body { cursor: auto; }
        a, button, [role="button"], .back-button { cursor: pointer; }

        /* Disable previous neon water cursor visuals */
        body.water-cursor-enabled { cursor: auto; }
        .water-cursor {
            display: none !important;
        }
        .water-ripple {
            display: none !important;
        }
        @keyframes waterRipple { }
        /* search canvas subtle styling */
        #searchCanvas{ background: var(--bg-tertiary); border: 2px solid var(--shadow-primary); box-shadow: 0 0 8px var(--shadow-primary); border-radius:6px }
        
        /* Theme Toggle Button */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 30px;
            background: var(--button-bg);
            border: 2px solid var(--border-secondary);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            padding: 2px;
            z-index: 1001;
        }
        
        .theme-toggle:hover {
            box-shadow: 0 0 10px var(--shadow-primary);
        }
        
        .theme-toggle-slider {
            width: 24px;
            height: 24px;
            background: var(--text-accent);
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        [data-theme="light"] .theme-toggle-slider {
            transform: translateX(28px);
        }
        
        /* Responsive Canvas Design */
        @media (max-width: 1200px) {
            .container {
                max-width: 100%;
                gap: 15px;
            }
            
            .info-panel {
                width: 250px;
            }
            
            canvas {
                max-width: 100%;
                height: auto;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            
            .explanation-sidebar {
                width: 100%;
                max-width: 400px;
                order: 2;
            }
            
            .main-content {
                order: 1;
                width: 100%;
            }
            
            .info-panel {
                width: 100%;
                max-width: 400px;
                order: 3;
            }
            
            .pseudocode-box {
                max-height: 150px;
                font-size: 10px;
            }
            
            .pseudocode-box h2 {
                font-size: 0.9em;
            }
            
            canvas {
                width: 100%;
                max-width: 100%;
                height: 300px;
            }
            
            #searchCanvas {
                height: 60px;
            }
            
            #gridCanvas, #treeCanvas {
                height: 300px;
            }
            
            .controls {
                flex-direction: column;
                gap: 10px;
                width: 100%;
            }
            
            .controls > div {
                width: 100%;
                display: flex;
                justify-content: center;
            }
            
            select, button {
                width: 100%;
                max-width: 200px;
            }
            
            h1 {
                font-size: 2em;
                text-align: center;
            }
            
            .theme-toggle {
                top: 10px;
                right: 10px;
                width: 50px;
                height: 25px;
            }
            
            .theme-toggle-slider {
                width: 20px;
                height: 20px;
                font-size: 10px;
            }
            
            [data-theme="light"] .theme-toggle-slider {
                transform: translateX(23px);
            }
        }
        
        @media (max-width: 480px) {
            canvas {
                height: 250px;
            }
            
            #searchCanvas {
                height: 50px;
            }
            
            #gridCanvas, #treeCanvas {
                height: 250px;
            }
            
            .info-panel {
                padding: 15px;
            }
            
            .pseudocode {
                font-size: 11px;
                padding: 10px;
            }
        }
        
        /* Preserve external cursor while controlling overflow */
        body { overflow-x: hidden; }
        
        .logo {
            cursor: pointer;
        }
        
        .magic-cursor {
            display: none;
        }
        
        .cursor-core {
            display: none;
        }
        
        .cursor-glow {
            display: none;
        }
        
        .magic-particle {
            display: none;
        }
        
        .explosion-particle {
            display: none;
        }
        
        .magic-ripple {
            display: none;
        }
        
        /* Summary Modal Styles */
        .summary-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
        }
        
        .summary-content {
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            margin: 3% auto;
            padding: 30px;
            border: 2px solid #00ffff;
            border-radius: 15px;
            width: 80%;
            max-width: 700px;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.4);
            position: relative;
            animation: summarySlideIn 0.4s ease-out;
        }
        
        @keyframes summarySlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .summary-header {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .summary-title {
            color: var(--text-accent);
            font-size: 2em;
            margin: 0 0 10px 0;
            text-shadow: 0 0 10px var(--text-accent);
        }
        
        .summary-algorithm {
            color: #ffd54f;
            font-size: 1.2em;
            margin: 0;
        }
        
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .summary-metric {
            background: #0d0d0d;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            text-align: center;
            transition: transform 0.2s ease;
        }
        
        .summary-metric:hover {
            transform: translateY(-2px);
            border-color: #00ffff;
        }
        
        .summary-metric-label {
            color: #a0a0a0;
            font-size: 0.9em;
            margin-bottom: 8px;
        }
        
        .summary-metric-value {
            color: #00ffff;
            font-size: 1.8em;
            font-weight: bold;
            font-family: monospace;
        }
        
        .summary-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }
        
        .summary-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .summary-btn-primary {
            background: linear-gradient(135deg, #00ffff, #00d2d2);
            color: #121212;
        }
        
        .summary-btn-secondary {
            background: linear-gradient(135deg, #333, #555);
            color: #e0e0e0;
            border: 1px solid #666;
        }
        
        .summary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }
        
        /* Comparison Mode Styles */
        .comparison-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1500;
        }
        
        .comparison-btn {
            background: linear-gradient(135deg, #9C27B0, #673AB7);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(156, 39, 176, 0.3);
            transition: all 0.3s ease;
        }
        
        .comparison-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.4);
        }
        
        .comparison-panel {
            display: none;
            position: fixed;
            top: 0;
            right: 0;
            width: 350px;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            border-left: 2px solid #9C27B0;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
            z-index: 1400;
            overflow-y: auto;
            padding: 20px;
        }
        
        .comparison-header {
            color: #9C27B0;
            font-size: 1.4em;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 2px solid #9C27B0;
            padding-bottom: 10px;
        }
        
        .comparison-item {
            background: #0d0d0d;
            margin: 15px 0;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            transition: border-color 0.2s ease;
        }
        
        .comparison-item:hover {
            border-color: #9C27B0;
        }
        
        .comparison-item-title {
            color: #00ffff;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .comparison-item-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.85em;
        }
        
        .comparison-stat {
            color: #a0a0a0;
        }
        
        .comparison-stat-value {
            color: #ffd54f;
            font-weight: 600;
        }
    </style>



</head>
<body>

    <!-- Neon water cursor container -->
    <div id="waterCursor" class="water-cursor" aria-hidden="true"></div>
    
    <!-- Theme Toggle Button -->
    <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
        <div class="theme-toggle-slider">🌙</div>
    </button>
    
    

    <div style="display:flex;align-items:center;gap:16px;margin-bottom:18px;">
        <button class="back-button" onclick="window.location.href='index.html'" style="margin-bottom:0;">← Back to Algorithms</button>
    </div>

    

    <h1>INSERTION SORT VISUALIZATION</h1>
    <div class="container">

        <div class="explanation-sidebar">
            <button class="explanation-btn" onclick="showAlgorithmExplanation()">
                📖 Algorithm Explanation
            </button>
            <button class="explanation-btn" onclick="toggleComplexityInfo()">
                ⏱️ Complexity Info
            </button>
            <button class="explanation-btn" onclick="showHowItWorks()">
                🔧 How It Works
            </button>
            <button class="explanation-btn" onclick="showUseCases()">
                💡 Use Cases
            </button>
        </div>
        
        <div class="main-content">
            <canvas id="visualizerCanvas" width="800" height="400"></canvas>
            <!-- Compact canvas to illustrate search steps (indices, left/mid/right highlights) -->
            <canvas id="searchCanvas" width="800" height="80" style="display:none;margin-top:12px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);"></canvas>
            <!-- Grid canvas for path finding algorithms -->
            <canvas id="gridCanvas" width="800" height="400" style="display:none;margin-top:12px;border-radius:6px;border:2px solid #4CAF50;background:#1a1a1a;"></canvas>
            <!-- Tree canvas for tree traversal algorithms -->
            <canvas id="treeCanvas" width="800" height="500" style="display:none;margin-top:12px;border-radius:6px;border:2px solid #9C27B0;background:#1a1a1a;"></canvas>
            <div class="controls">
                <div style="position:relative;">
                    <label for="speed-select">Speed:</label>
                    <select id="speed-select">
                        <option value="1000">Slow</option>
                        <option value="250" selected>Medium</option>
                        <option value="1">Fast</option>
                    </select>
                    <div style="display:inline-block;position:relative;margin-left:8px;">
                        <button id="customSpeedBtn" style="padding:6px 8px;border-radius:6px;background:#333;color:#e0e0e0;border:1px solid #00ffff;">Custom</button>
                        <div id="rightSpeedContainer" style="display:none;position:absolute;top:calc(100% + 8px);right:0;min-width:220px;background:#0d0d0d;border:1px solid #00ffff;padding:12px;border-radius:8px;box-shadow:0 8px 20px rgba(0,0,0,0.6);z-index:10000;">
                            
                            
                            <div style="display:flex;align-items:center;gap:8px;">
                                <button id="speed-minus" title="-10 ms" style="padding:4px 8px;border-radius:6px;background:#222;color:#e0e0e0;border:1px solid #00ffff;">-10</button>
                                <input id="speed-number" type="number" min="1" max="1000" step="1" value="250" style="width:80px;padding:6px;border-radius:6px;border:1px solid #00ffff;background:#111;color:#e0e0e0;">
                                <button id="speed-plus" title="+10 ms" style="padding:4px 8px;border-radius:6px;background:#222;color:#e0e0e0;border:1px solid #00ffff;">+10</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                <div id="data-input-row" style="display:flex;align-items:center;gap:8px;">
                    <label for="data-input" style="margin:0;font-size:14px;color:#e0e0e0">Data:</label>
                    <input id="data-input" placeholder="e.g. 5 3 8 2 9" style="padding:8px;border-radius:4px;border:1px solid #00ffff;background:#222;color:#e0e0e0;width:220px">
                    <button id="setDataBtn" style="padding:8px;border-radius:6px;background:#00d4c4;border:none;color:#031617;cursor:pointer;font-weight:600">Set Data</button>
                </div>
                <div style="display:flex;align-items:center;gap:8px;">
                    <label for="target-input" style="margin:0;font-size:14px;color:#e0e0e0">Target:</label>
                    <input id="target-input" placeholder="Enter insert number" style="padding:8px;border-radius:4px;border:1px solid #00ffff;background:#222;color:#e0e0e0;width:160px">
                </div>
                <div id="position-input-row" style="display:none;align-items:center;gap:8px;">
                    <label for="position-input" style="margin:0;font-size:14px;color:#e0e0e0">Position:</label>
                    <input id="position-input" type="number" min="0" step="1" placeholder="index (optional)" style="padding:8px;border-radius:4px;border:1px solid #00ffff;background:#222;color:#e0e0e0;width:160px">
                    <button id="insertAtPosBtn" style="padding:8px;border-radius:6px;background:#00c853;border:none;color:#031617;cursor:pointer;font-weight:600">Insert</button>
                </div>
                <button id="exampleDataBtn">Example Data</button>
                <button id="startBtn">Start</button>
                <button id="pauseBtn" disabled>Pause</button>
                <button id="stopBtn" disabled>Stop</button>
                <button id="step-backward" disabled>Step Backward (⏪)</button>
                <button id="step-forward" disabled>Step Forward (⏩)</button>
                
                <!-- Pathfinding Controls -->
                <div id="pathfinding-controls" style="display:none;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px;padding-top:8px;border-top:1px solid #333;">
                    <button id="clear-grid" style="padding:8px 12px;border-radius:6px;background:#ff5722;border:none;color:white;cursor:pointer;font-weight:600;">Clear Grid</button>
                    <button id="randomize-walls" style="padding:8px 12px;border-radius:6px;background:#9c27b0;border:none;color:white;cursor:pointer;font-weight:600;">Randomize Walls</button>
                    <div style="display:flex;align-items:center;gap:4px;margin-left:8px;">
                        <span style="font-size:12px;color:#e0e0e0;">Mode:</span>
                        <select id="drawing-mode" style="padding:4px;border-radius:4px;border:1px solid #00ffff;background:#222;color:#e0e0e0;">
                            <option value="wall">Draw Walls</option>
                            <option value="weight">Add Weights</option>
                            <option value="start">Move Start</option>
                            <option value="end">Move End</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        <div class="info-panel">
            <div class="message-box">
                <h2>Explanation</h2>
                <div id="message">Ready to visualize. Press Start.</div>
            </div>
            <div class="complexity-box" id="complexityBox">
                <h2>Performance Metrics</h2>
                <div id="metricsContent">
                    <div class="metrics-item">
                        <span class="metrics-label">Comparisons:</span>
                        <span class="metrics-value" id="comparisonsCount">0</span>
                    </div>
                    <div class="metrics-item">
                        <span class="metrics-label">Swaps/Moves:</span>
                        <span class="metrics-value" id="swapsCount">0</span>
                    </div>
                    <div class="metrics-item">
                        <span class="metrics-label">Time Elapsed:</span>
                        <span class="metrics-value" id="timeElapsed">0ms</span>
                    </div>
                </div>
            </div>
            <!-- custom speed popover is anchored to the Custom button near the top; no duplicate here -->
            <div class="pseudocode-box">
                <h2>Pseudocode</h2>
                <pre id="pseudocode"></pre>
            </div>
            <!-- Current Data readout removed as requested -->
        </div>
    </div>

    <script>
        // Simple explanations for each algorithm
        const simpleExplanations = {
            bubbleSort: "Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. It continues until the list is sorted.",
            insertionSort: "Insertion Sort builds the sorted array one item at a time by inserting each new element into its correct position among the already sorted elements.",
            selectionSort: "Selection Sort divides the array into sorted and unsorted parts, repeatedly finding the smallest element from the unsorted part and moving it to the sorted part.",
            quickSort: "Quick Sort is a divide-and-conquer algorithm that picks a pivot, partitions the array around the pivot, and recursively sorts the partitions.",
            mergeSort: "Merge Sort splits the array into halves, recursively sorts each half, and then merges the sorted halves back together.",
            linearSearch: "Linear Search checks each element in the list one by one until it finds the target value or reaches the end.",
            binarySearch: "Binary Search works on sorted arrays by repeatedly dividing the search interval in half, comparing the middle element to the target, and narrowing the search range until the target is found or not present.",
            insertMethod: "Insert Method finds the correct position to insert a new value while maintaining the sorted order of the array. It searches for the appropriate position and inserts the element there.",
            deleteMethod: "Delete Method searches for a specific value in the array and removes it if found. It performs a linear search to locate the element and then removes it from the array.",
            // DFS and BFS descriptions removed
            treeDfs: "Tree DFS traverses a tree by going as deep as possible along each branch before backtracking. It visits nodes in pre-order: root, left subtree, right subtree.",
            treeBfs: "Tree BFS traverses a tree level by level, visiting all nodes at the current depth before moving to the next level. It guarantees visiting nodes in breadth-first order."
        };

    let lastConditionDetail = '';
        // Get the algorithm from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const selectedAlgorithm = urlParams.get('algorithm') || 'bubbleSort';
        
        // Define color schemes for each algorithm
        const algorithmColors = {
            bubbleSort: {
                base: '#FF69B4',    // Hot Pink
                comparing: '#3236a8' // Deep Pink
            },
            insertionSort: {
                base: '#4CAF50',    // Material Green
                comparing: '#ffa31a' // Dark Green
            },
            selectionSort: {
                base: '#FFA500',    // Orange
                comparing: '#FF4500' // Orange Red
            },
            quickSort: {
                base: '#9C27B0',    // Purple
                comparing: '#ff0000' // Dark Purple
            },
            mergeSort: {
                base: '#2196F3',    // Blue
                comparing: '#13d126' // Dark Blue
            },
            linearSearch: {
                base: '#d113b8',    // Requested base color
                comparing: '#ff66cc' // Highlight color for comparisons
            },
            insertMethod: {
                base: '#00ffff',    // Default base for data manipulation
                comparing: '#ffbf00' // Requested compare color
            },
            deleteMethod: {
                base: '#00ffff',    // Default base for data manipulation
                comparing: '#1a8cff' // Requested compare color
            }
        };

        // safe lookup for selected algorithm colors (fallback if missing)
        const colorsForSelected = algorithmColors[selectedAlgorithm] || { base: '#00ffff', comparing: '#ff0066' };
        
        // Update title with algorithm name
        document.title = `${selectedAlgorithm.replace(/([A-Z])/g, ' $1').trim()} Visualization`;
        document.querySelector('h1').textContent = `${selectedAlgorithm.replace(/([A-Z])/g, ' $1').trim()} Visualization`;
        
    // Theme Management
    function initializeTheme() {
        const savedTheme = localStorage.getItem('theme') || 'dark';
        const html = document.documentElement;
        const slider = document.querySelector('.theme-toggle-slider');
        
        if (savedTheme === 'light') {
            html.setAttribute('data-theme', 'light');
            if (slider) slider.textContent = '☀️';
        } else {
            html.removeAttribute('data-theme');
            if (slider) slider.textContent = '🌙';
        }
    }
    
    function toggleTheme() {
        const html = document.documentElement;
        const slider = document.querySelector('.theme-toggle-slider');
        const currentTheme = html.getAttribute('data-theme');
        
        if (currentTheme === 'light') {
            html.removeAttribute('data-theme');
            if (slider) slider.textContent = '🌙';
            localStorage.setItem('theme', 'dark');
        } else {
            html.setAttribute('data-theme', 'light');
            if (slider) slider.textContent = '☀️';
            localStorage.setItem('theme', 'light');
        }
    }
    
    // Initialize theme on page load
    document.addEventListener('DOMContentLoaded', function() {
        initializeTheme();
        updateCanvasSize();
        drawBars();
    });
    
    // Handle window resize for responsive canvas
    window.addEventListener('resize', function() {
        updateCanvasSize();
        drawBars();
        if (searchAlgos.has(selectedAlgorithm)) {
            drawSearchCanvas({});
        }
    });
    
    // Set the algorithm color as a CSS variable (safe)
    document.documentElement.style.setProperty('--algorithm-color', colorsForSelected.base);

        const canvas = document.getElementById('visualizerCanvas');
        const ctx = canvas.getContext('2d');
    const speedSelect = document.getElementById('speed-select');
    const exampleDataBtn = document.getElementById('exampleDataBtn');
    const speedRange = document.getElementById('speed-range');
    const speedNumber = document.getElementById('speed-number');
    const speedMinus = document.getElementById('speed-minus');
    const speedPlus = document.getElementById('speed-plus');
    const speedValueLabel = document.getElementById('speed-range-value');
    const speedOpsLabel = document.getElementById('speed-ops');
        const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const stepBackwardBtn = document.getElementById('step-backward');
    const stepForwardBtn = document.getElementById('step-forward');
    const customSpeedBtn = document.getElementById('customSpeedBtn');
    const rightSpeedContainer = document.getElementById('rightSpeedContainer');
        const pseudocodeEl = document.getElementById('pseudocode');
        const messageEl = document.getElementById('message');
    let isPaused = false;
    const searchCanvasEl = document.getElementById('searchCanvas');
    const targetInputEl = document.getElementById('target-input');
    const positionInputRow = document.getElementById('position-input-row');
    const positionInput = document.getElementById('position-input');
    const insertAtPosBtn = document.getElementById('insertAtPosBtn');

        const NUM_BARS = 50;
        const BAR_WIDTH = canvas.width / NUM_BARS;
        let data = [];
        let originalValues = [];
        let isSorting = false;
        let stopSorting = false;
        
        // State management for reversible control
        let historyStack = [];
        let futureStates = [];
        let isSteppingMode = false;
        let currentAlgorithmState = null;
        
        // Performance metrics tracking
        let totalComparisons = 0;
        let totalSwaps = 0;
        let startTime = 0;
        let timeElapsed = 0;
        let performanceUpdateInterval = null;
        
        const exampleData = [45, 12, 67, 34, 98, 21, 56, 78, 10, 89, 43, 29, 72, 5, 84, 61, 38, 93, 15, 76];
        let useExampleData = false;

        const pseudocodes = {
            bubbleSort: [
                "for i = 0 to n-1",
                "  for j = 0 to n-i-2", 
                "    if array[j] > array[j+1]",
                "      swap(array[j], array[j+1])"
            ],
            insertionSort: [
                "for i = 1 to n-1",
                "  key = array[i]",
                "  j = i - 1", 
                "  while j >= 0 and array[j] > key",
                "    array[j+1] = array[j]",
                "    j = j - 1",
                "  array[j+1] = key"
            ],
            selectionSort: [
                "for i = 0 to n-1",
                "  minIndex = i",
                "  for j = i+1 to n-1",
                "    if array[j] < array[minIndex]",
                "      minIndex = j",
                "  swap(array[i], array[minIndex])"
            ],
            quickSort: [
                "quickSort(array, low, high):",
                "  if low < high:",
                "    pivot = partition(array, low, high)",
                "    quickSort(array, low, pivot-1)",
                "    quickSort(array, pivot+1, high)",
                "",
                "partition(array, low, high):",
                "  pivot = array[high]",
                "  i = low - 1",
                "  for j = low to high-1:",
                "    if array[j] <= pivot:",
                "      i++",
                "      swap(array[i], array[j])",
                "  swap(array[i+1], array[high])",
                "  return i+1"
            ],
            mergeSort: [
                "mergeSort(array, left, right):",
                "  if left < right:",
                "    mid = (left + right) / 2",
                "    mergeSort(array, left, mid)",
                "    mergeSort(array, mid+1, right)",
                "    merge(array, left, mid, right)",
                "",
                "merge(array, left, mid, right):",
                "  create temp arrays L and R",
                "  copy data to temp arrays",
                "  merge temp arrays back to array[left..right]"
            ],
            linearSearch: [
                "linearSearch(array, target):",
                "  for i = 0 to n-1:",
                "    if array[i] == target:",
                "      return i",
                "  return -1"
            ],
            binarySearch: [
                "binarySearch(array, target):",
                "  left = 0",
                "  right = n - 1",
                "  while left <= right:",
                "    mid = (left + right) / 2",
                "    if array[mid] == target:",
                "      return mid",
                "    else if array[mid] < target:",
                "      left = mid + 1",
                "    else:",
                "      right = mid - 1",
                "  return -1"
            ],
            insertMethod: [
                "insertMethod(array, value):",
                "  position = array.length",
                "  for i = 0 to array.length-1:",
                "    if value <= array[i]:",
                "      position = i",
                "      break",
                "  insert value at position",
                "  return position"
            ],
            deleteMethod: [
                "deleteMethod(array, value):",
                "  for i = 0 to array.length-1:",
                "    if array[i] == value:",
                "      remove element at index i",
                "      return i",
                "  return -1"
            ],
            treeDfs: [
                "treeDfs(node):",
                "  if node is null:",
                "    return",
                "  visit(node)",
                "  treeDfs(node.left)",
                "  treeDfs(node.right)"
            ],
            treeBfs: [
                "treeBfs(root):",
                "  queue = [root]",
                "  while queue not empty:",
                "    node = queue.shift()",
                "    visit(node)",
                "    if node.left:",
                "      queue.push(node.left)",
                "    if node.right:",
                "      queue.push(node.right)"
            ],
            dijkstra: [
                "dijkstra(graph, start, end):",
                "  distances[start] = 0",
                "  priority_queue = [(0, start)]",
                "  while priority_queue not empty:",
                "    current_dist, current = pop_min(priority_queue)",
                "    if current == end:",
                "      return path",
                "    for neighbor in graph[current]:",
                "      new_dist = current_dist + weight(current, neighbor)",
                "      if new_dist < distances[neighbor]:",
                "        distances[neighbor] = new_dist",
                "        parent[neighbor] = current",
                "        push(priority_queue, (new_dist, neighbor))"
            ],
            astar: [
                "astar(graph, start, end):",
                "  g_score[start] = 0",
                "  f_score[start] = heuristic(start, end)",
                "  open_set = [(f_score[start], start)]",
                "  while open_set not empty:",
                "    current = pop_min(open_set)",
                "    if current == end:",
                "      return reconstruct_path()",
                "    for neighbor in graph[current]:",
                "      tentative_g = g_score[current] + weight(current, neighbor)",
                "      if tentative_g < g_score[neighbor]:",
                "        g_score[neighbor] = tentative_g",
                "        f_score[neighbor] = tentative_g + heuristic(neighbor, end)",
                "        parent[neighbor] = current",
                "        push(open_set, (f_score[neighbor], neighbor))"
            ]
        };

        // Utility to update current data readout and internal arrays
        const dataInput = document.getElementById('data-input');
        const setDataBtn = document.getElementById('setDataBtn');
        const currentDataEl = document.getElementById('currentData');

        function updateCurrentDataReadout() {
            if (!currentDataEl) return;
            if (!originalValues || originalValues.length === 0) {
                currentDataEl.textContent = 'No data set yet.';
            } else {
                currentDataEl.textContent = originalValues.join(', ');
            }
        }

        function setDataFromInput() {
            const text = dataInput.value.trim();
            if (!text) return;
            // parse numbers separated by space/comma
            const arr = text.split(/[ ,]+/).map(s => parseFloat(s)).filter(n => !isNaN(n));
            if (arr.length === 0) return;
            originalValues = arr.slice();
            // scale to canvas for bar heights
            const maxVal = Math.max(...originalValues);
            data = originalValues.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
            drawBars();
            if (searchAlgos.has(selectedAlgorithm)) drawSearchCanvas({});
            updateCurrentDataReadout();
        }

        if (setDataBtn) setDataBtn.addEventListener('click', setDataFromInput);
        updateCurrentDataReadout();

    // Sync top and right speed selectors (two-way) and advanced inputs
    // keep range in sync with top select
    // Sync range with selects and support custom range value
    function setCustomOptionIn(selectEl, val) {
        // Remove any existing custom option first
        const existing = selectEl.querySelector('option#customSpeedOption');
        if (existing) existing.remove();
        // If val matches a standard option, just set and return
        if (['1','250','1000'].includes(String(val))) {
            selectEl.value = String(val);
            return;
        }
        const opt = document.createElement('option');
        opt.id = 'customSpeedOption';
        opt.value = String(val);
        opt.textContent = `Custom (${val}ms)`;
        selectEl.appendChild(opt);
        selectEl.value = String(val);
    }

    function clampSpeed(v){
        const n = Math.max(1, Math.min(1000, parseInt(v, 10) || 250));
        return n;
    }

    function updateSpeedLabels(v){
        if (speedValueLabel) speedValueLabel.textContent = String(v);
        // ops per second ~ 1000/v, rounded to integer
        if (speedOpsLabel) {
            const ops = Math.max(1, Math.round(1000 / v));
            speedOpsLabel.textContent = String(ops);
        }
    }

    function applySpeed(v, persist = true){
        const val = clampSpeed(v);
        if (speedSelect) setCustomOptionIn(speedSelect, String(val));
        if (speedRange) speedRange.value = String(val);
        if (speedNumber) speedNumber.value = String(val);
        updateSpeedLabels(val);
        if (persist) try { localStorage.setItem('algoViz_speed_ms', String(val)); } catch (e) {}
    }

    // initialize controls from persisted value or current select
    (function initSpeed(){
        let initial = 250;
        try { const saved = localStorage.getItem('algoViz_speed_ms'); if (saved) initial = clampSpeed(saved); } catch (e) {}
        if (speedSelect) {
            // if no saved, use current select value
            if (!localStorage.getItem('algoViz_speed_ms')) initial = clampSpeed(speedSelect.value);
        }
        applySpeed(initial, false);
    })();

    // Listeners
    if (speedSelect) {
        speedSelect.addEventListener('change', () => {
            applySpeed(speedSelect.value);
        });
    }

    if (speedRange) {
        speedRange.addEventListener('input', () => {
            applySpeed(speedRange.value);
        });
    }

    if (speedNumber) {
        speedNumber.addEventListener('input', () => {
            applySpeed(speedNumber.value);
        });
    }

    if (speedMinus) {
        speedMinus.addEventListener('click', () => {
            const current = clampSpeed(speedNumber ? speedNumber.value : (speedRange ? speedRange.value : 250));
            applySpeed(current - 10);
        });
    }

    if (speedPlus) {
        speedPlus.addEventListener('click', () => {
            const current = clampSpeed(speedNumber ? speedNumber.value : (speedRange ? speedRange.value : 250));
            applySpeed(current + 10);
        });
    }

    // Custom button toggles right-side speed controls
    if (customSpeedBtn && rightSpeedContainer) {
        customSpeedBtn.addEventListener('click', () => {
            const isHidden = rightSpeedContainer.style.display === 'none' || !rightSpeedContainer.style.display;
            rightSpeedContainer.style.display = isHidden ? 'flex' : 'none';
            if (isHidden) {
                // when showing, sync labels to current value
                const current = (speedNumber && speedNumber.value) ? speedNumber.value : (speedSelect ? speedSelect.value : '250');
                const lbl = document.getElementById('speed-range-value'); if (lbl) lbl.textContent = String(current);
                updateSpeedLabels(clampSpeed(current));
                // focus input for quick adjustment
                setTimeout(() => { if (speedNumber) speedNumber.focus(); }, 60);
            }
        });
    }

    // Show search UI elements only for search and data manipulation algorithms
    const searchAlgos = new Set(['linearSearch','binarySearch','insertMethod','deleteMethod']);
    const pathfindingAlgos = new Set(['dijkstra', 'astar']);
    const treeAlgos = new Set(['treeDfs','treeBfs']);
    const gridCanvasEl = document.getElementById('gridCanvas');
    const treeCanvasEl = document.getElementById('treeCanvas');
    const mainCanvasEl = document.getElementById('visualizerCanvas');
    const dataInputRowEl = document.getElementById('data-input-row');
    const targetLabelEl = document.querySelector('label[for="target-input"]');
    
    if (searchCanvasEl) searchCanvasEl.style.display = searchAlgos.has(selectedAlgorithm) ? '' : 'none';
    if (targetInputEl) targetInputEl.style.display = searchAlgos.has(selectedAlgorithm) ? '' : 'none';
    if (gridCanvasEl) gridCanvasEl.style.display = pathfindingAlgos.has(selectedAlgorithm) ? '' : 'none';
    if (treeCanvasEl) treeCanvasEl.style.display = treeAlgos.has(selectedAlgorithm) ? '' : 'none';
    if (mainCanvasEl) mainCanvasEl.style.display = (treeAlgos.has(selectedAlgorithm) || pathfindingAlgos.has(selectedAlgorithm)) ? 'none' : '';
    if (dataInputRowEl) dataInputRowEl.style.display = (treeAlgos.has(selectedAlgorithm) || pathfindingAlgos.has(selectedAlgorithm)) ? 'none' : '';
    
    // Show/hide pathfinding controls
    const pathfindingControlsEl = document.getElementById('pathfinding-controls');
    if (pathfindingControlsEl) pathfindingControlsEl.style.display = pathfindingAlgos.has(selectedAlgorithm) ? 'flex' : 'none';
    if (targetLabelEl) targetLabelEl.style.display = searchAlgos.has(selectedAlgorithm) ? '' : 'none';
    if (exampleDataBtn) exampleDataBtn.style.display = treeAlgos.has(selectedAlgorithm) ? 'none' : '';
    if (positionInputRow) positionInputRow.style.display = (selectedAlgorithm === 'insertMethod') ? 'flex' : 'none';

    // Adjust placeholder text based on algorithm
    if (targetInputEl) {
        const placeholderMap = {
            insertMethod: 'Enter insert number',
            deleteMethod: 'Enter delete element',
            linearSearch: 'Enter target',
            binarySearch: 'Enter target'
        };
        targetInputEl.placeholder = placeholderMap[selectedAlgorithm] || targetInputEl.placeholder;
    }

    

        // Responsive canvas sizing function
        function updateCanvasSize() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            
            // Set canvas dimensions based on screen size
            if (isSmallMobile) {
                canvas.width = Math.min(containerWidth - 20, 350);
                canvas.height = 250;
            } else if (isMobile) {
                canvas.width = Math.min(containerWidth - 20, 500);
                canvas.height = 300;
            } else {
                canvas.width = Math.min(containerWidth - 20, 800);
                canvas.height = 400;
            }
            
            // Update other canvases too
            if (searchCanvas) {
                searchCanvas.width = canvas.width;
                searchCanvas.height = isMobile ? (isSmallMobile ? 50 : 60) : 80;
            }
            if (gridCanvas) {
                gridCanvas.width = canvas.width;
                gridCanvas.height = canvas.height;
            }
            if (treeCanvas) {
                treeCanvas.width = canvas.width;
                treeCanvas.height = canvas.height + 100;
            }
        }
        
        function drawBars(bar1 = -1, bar2 = -1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const currentNumBars = data.length;
            
            // Calculate responsive bar width and spacing so small arrays fill the canvas
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            
            let minBarWidth = isSmallMobile ? 8 : isMobile ? 12 : 16;
            // Reduce spacing for very small arrays to allow full-width fill
            let barSpacing = (currentNumBars <= 3) ? 0 : (isSmallMobile ? 1 : 2);
            
            // Compute bar width to occupy available canvas width
            let calculatedBarWidth = (canvas.width - ((currentNumBars - 1) * barSpacing)) / currentNumBars;
            let currentBarWidth = Math.max(minBarWidth, Math.floor(calculatedBarWidth));
            
            // If bars would be too narrow, reduce the number of visible bars on mobile
            let visibleBars = currentNumBars;
            if (isMobile && currentBarWidth < minBarWidth && currentNumBars > 20) {
                visibleBars = Math.floor(canvas.width / (minBarWidth + barSpacing));
                currentBarWidth = minBarWidth;
            }
            
            // Center bars horizontally
            const totalUsedWidth = (currentBarWidth * Math.min(visibleBars, currentNumBars)) + (barSpacing * (Math.min(visibleBars, currentNumBars) - 1));
            const xStart = Math.max(0, Math.floor((canvas.width - totalUsedWidth) / 2));
            
            const colors = algorithmColors[selectedAlgorithm] || { base: '#e0e0e0', comparing: '#8ff' };
            
            for (let k = 0; k < Math.min(visibleBars, currentNumBars); k++) {
                let color = colors.base;
                if (k === bar1 || k === bar2) {
                    color = colors.comparing;
                }
                ctx.fillStyle = color;
                const xPos = xStart + k * (currentBarWidth + barSpacing);
                ctx.fillRect(xPos, canvas.height - data[k], currentBarWidth, data[k]);

                // Adjust font size based on bar width and screen size
                const fontSize = Math.max(8, Math.min(12, currentBarWidth * 0.6));
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-primary') || '#e0e0e0';
                ctx.font = `${fontSize}px Segoe UI`;
                ctx.textAlign = 'center';
                
                const numberText = originalValues[k].toString();
                const textX = xPos + currentBarWidth / 2;
                const textY = canvas.height - data[k] - 5;
                
                // Only show text if bar is wide enough
                if (currentBarWidth >= 15) {
                    ctx.fillText(numberText, textX, textY);
                }
            }
            
            // Show indication if not all bars are visible
            if (visibleBars < currentNumBars) {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary') || '#a0a0a0';
                ctx.font = '12px Segoe UI';
                ctx.textAlign = 'right';
                ctx.fillText(`Showing ${visibleBars}/${currentNumBars} elements`, canvas.width - 10, 20);
            }
        }

        // Draw compact search visualization (indices, highlights)
        const searchCanvas = document.getElementById('searchCanvas');
        const sCtx = searchCanvas ? searchCanvas.getContext('2d') : null;
        function drawSearchCanvas(highlight = {}){
            if (!sCtx) return;
            const arr = originalValues.slice(0, 30); // show up to first 30 elements for clarity
            const w = searchCanvas.width;
            const h = searchCanvas.height;
            sCtx.clearRect(0,0,w,h);
            const cols = arr.length;
            const cellW = Math.max(20, Math.floor(w / cols));
            const pad = 6;
            sCtx.font = '12px Segoe UI';
            sCtx.textAlign = 'center';

            for (let i=0;i<cols;i++){
                const x = i*cellW + cellW/2;
                const y = h/2;
                // background
                let bg = 'rgba(255,255,255,0.03)';
                if (i === highlight.mid) bg = 'rgba(0,200,255,0.18)';
                if (i === highlight.left) bg = 'rgba(0,255,100,0.14)';
                if (i === highlight.right) bg = 'rgba(255,100,0,0.14)';
                if (i === highlight.checked) bg = 'rgba(255,45,149,0.18)';
                sCtx.fillStyle = bg;
                sCtx.fillRect(i*cellW+pad/2, 6, cellW-pad, h-12);

                // value
                sCtx.fillStyle = '#e0e0e0';
                sCtx.fillText(String(arr[i]), x, y);
            }
            // For binary search, label beg, mid, end above the highlighted elements
            if (selectedAlgorithm === 'binarySearch') {
                const yTop = 14;
                if (typeof highlight.left === 'number' && highlight.left >= 0 && highlight.left < cols) {
                    const xLeft = highlight.left * cellW + cellW/2;
                    sCtx.fillStyle = '#48ff91'; // green-ish for beg
                    sCtx.fillText('beg', xLeft, yTop);
                }
                if (typeof highlight.mid === 'number' && highlight.mid >= 0 && highlight.mid < cols) {
                    const xMid = highlight.mid * cellW + cellW/2;
                    sCtx.fillStyle = '#8ff'; // cyan for mid
                    sCtx.fillText('mid', xMid, yTop);
                }
                if (typeof highlight.right === 'number' && highlight.right >= 0 && highlight.right < cols) {
                    const xRight = highlight.right * cellW + cellW/2;
                    sCtx.fillStyle = '#ffa366'; // orange for end
                    sCtx.fillText('end', xRight, yTop);
                }
            }
        }

        // Grid-based path finding visualization
        const gridCanvas = document.getElementById('gridCanvas');
        const gCtx = gridCanvas ? gridCanvas.getContext('2d') : null;
        
        // Grid configuration
        const GRID_SIZE = 20;
        const COLS = Math.floor(gridCanvas.width / GRID_SIZE);
        const ROWS = Math.floor(gridCanvas.height / GRID_SIZE);
        
        // Grid states
        const GRID_STATES = {
            EMPTY: 0,
            WALL: 1,
            START: 2,
            END: 3,
            VISITED: 4,
            PATH: 5,
            CURRENT: 6,
            WEIGHT_2: 7,
            WEIGHT_3: 8,
            WEIGHT_4: 9,
            WEIGHT_5: 10,
            IN_QUEUE: 11
        };
        
        let grid = [];
        let startPos = { row: 2, col: 2 };
        let endPos = { row: ROWS - 3, col: COLS - 3 };
        let currentPath = [];
        let visitedCells = [];
        
        function initializeGrid() {
            grid = [];
            for (let row = 0; row < ROWS; row++) {
                grid[row] = [];
                for (let col = 0; col < COLS; col++) {
                    // Create walls around the border
                    if (row === 0 || row === ROWS - 1 || col === 0 || col === COLS - 1) {
                        grid[row][col] = GRID_STATES.WALL;
                    } else {
                        grid[row][col] = GRID_STATES.EMPTY;
                    }
                }
            }
            
            // Set start and end positions
            grid[startPos.row][startPos.col] = GRID_STATES.START;
            grid[endPos.row][endPos.col] = GRID_STATES.END;
            
            // Add some random obstacles
            for (let i = 0; i < 30; i++) {
                const row = Math.floor(Math.random() * (ROWS - 2)) + 1;
                const col = Math.floor(Math.random() * (COLS - 2)) + 1;
                if (grid[row][col] === GRID_STATES.EMPTY) {
                    grid[row][col] = GRID_STATES.WALL;
                }
            }
            
            drawGrid();
        }
        
        function drawGrid() {
            if (!gCtx) return;
            
            gCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const x = col * GRID_SIZE;
                    const y = row * GRID_SIZE;
                    
                    switch (grid[row][col]) {
                        case GRID_STATES.EMPTY:
                            gCtx.fillStyle = '#2a2a2a';
                            break;
                        case GRID_STATES.WALL:
                            gCtx.fillStyle = '#1a1a1a';
                            break;
                        case GRID_STATES.START:
                            gCtx.fillStyle = '#4CAF50'; // Green
                            break;
                        case GRID_STATES.END:
                            gCtx.fillStyle = '#F44336'; // Red
                            break;
                        case GRID_STATES.VISITED:
                            gCtx.fillStyle = 'rgba(33, 150, 243, 0.6)'; // Fading Blue
                            break;
                        case GRID_STATES.PATH:
                            gCtx.fillStyle = '#00FFFF'; // Intense Cyan
                            break;
                        case GRID_STATES.CURRENT:
                            gCtx.fillStyle = '#FFEB3B'; // Yellow
                            break;
                        case GRID_STATES.WEIGHT_2:
                            gCtx.fillStyle = '#8BC34A'; // Light Green
                            break;
                        case GRID_STATES.WEIGHT_3:
                            gCtx.fillStyle = '#FFC107'; // Amber
                            break;
                        case GRID_STATES.WEIGHT_4:
                            gCtx.fillStyle = '#FF9800'; // Orange
                            break;
                        case GRID_STATES.WEIGHT_5:
                            gCtx.fillStyle = '#FF5722'; // Deep Orange
                            break;
                        case GRID_STATES.IN_QUEUE:
                            gCtx.fillStyle = 'rgba(255, 193, 7, 0.8)'; // Glowing Yellow/Orange
                            break;
                    }
                    
                    gCtx.fillRect(x, y, GRID_SIZE - 1, GRID_SIZE - 1);
                    
                    // Draw grid lines
                    gCtx.strokeStyle = '#1a1a1a';
                    gCtx.lineWidth = 1;
                    gCtx.strokeRect(x, y, GRID_SIZE, GRID_SIZE);
                }
            }
        }
        
        function getNeighbors(row, col) {
            const neighbors = [];
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right
            ];
            
            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < ROWS && 
                    newCol >= 0 && newCol < COLS && 
                    grid[newRow][newCol] !== GRID_STATES.WALL) {
                    neighbors.push({ row: newRow, col: newCol });
                }
            }
            
            return neighbors;
        }
        
        function reconstructPath(cameFrom, current) {
            const path = [current];
            while (cameFrom.has(`${current.row},${current.col}`)) {
                current = cameFrom.get(`${current.row},${current.col}`);
                path.unshift(current);
            }
            return path;
        }

        // Mouse interaction for grid
        let isMouseDown = false;
        let currentDrawingMode = 'wall';
        
        function getGridPosition(event) {
            const rect = gridCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const col = Math.floor(x / GRID_SIZE);
            const row = Math.floor(y / GRID_SIZE);
            return { row, col };
        }
        
        function handleGridClick(event) {
            if (isSorting) return;
            const { row, col } = getGridPosition(event);
            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;
            
            const currentState = grid[row][col];
            
            switch (currentDrawingMode) {
                case 'wall':
                    if (currentState !== GRID_STATES.START && currentState !== GRID_STATES.END) {
                        grid[row][col] = currentState === GRID_STATES.WALL ? GRID_STATES.EMPTY : GRID_STATES.WALL;
                    }
                    break;
                case 'weight':
                    if (currentState === GRID_STATES.EMPTY) {
                        grid[row][col] = GRID_STATES.WEIGHT_2;
                    } else if (currentState >= GRID_STATES.WEIGHT_2 && currentState <= GRID_STATES.WEIGHT_4) {
                        grid[row][col] = currentState + 1;
                    } else if (currentState === GRID_STATES.WEIGHT_5) {
                        grid[row][col] = GRID_STATES.EMPTY;
                    }
                    break;
                case 'start':
                    if (currentState !== GRID_STATES.END) {
                        grid[startPos.row][startPos.col] = GRID_STATES.EMPTY;
                        startPos = { row, col };
                        grid[row][col] = GRID_STATES.START;
                    }
                    break;
                case 'end':
                    if (currentState !== GRID_STATES.START) {
                        grid[endPos.row][endPos.col] = GRID_STATES.EMPTY;
                        endPos = { row, col };
                        grid[row][col] = GRID_STATES.END;
                    }
                    break;
            }
            drawGrid();
        }
        
        function clearGrid() {
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (grid[row][col] === GRID_STATES.VISITED || 
                        grid[row][col] === GRID_STATES.PATH || 
                        grid[row][col] === GRID_STATES.CURRENT ||
                        grid[row][col] === GRID_STATES.IN_QUEUE) {
                        grid[row][col] = GRID_STATES.EMPTY;
                    }
                }
            }
            drawGrid();
        }
        
        function randomizeWalls() {
            // Clear existing walls first
            for (let row = 1; row < ROWS - 1; row++) {
                for (let col = 1; col < COLS - 1; col++) {
                    if (grid[row][col] === GRID_STATES.WALL) {
                        grid[row][col] = GRID_STATES.EMPTY;
                    }
                }
            }
            
            // Add random walls
            const wallDensity = 0.3;
            for (let row = 1; row < ROWS - 1; row++) {
                for (let col = 1; col < COLS - 1; col++) {
                    if (grid[row][col] === GRID_STATES.EMPTY && Math.random() < wallDensity) {
                        grid[row][col] = GRID_STATES.WALL;
                    }
                }
            }
            drawGrid();
        }
        
        function getNodeWeight(state) {
            switch (state) {
                case GRID_STATES.WEIGHT_2: return 2;
                case GRID_STATES.WEIGHT_3: return 3;
                case GRID_STATES.WEIGHT_4: return 4;
                case GRID_STATES.WEIGHT_5: return 5;
                default: return 1;
            }
        }
        
        // Dijkstra's Algorithm Implementation
        async function dijkstra() {
            clearGrid();
            isSorting = true;
            stopSorting = false;
            
            const distances = new Map();
            const previous = new Map();
            const unvisited = new Set();
            
            // Initialize distances
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const key = `${row},${col}`;
                    distances.set(key, Infinity);
                    unvisited.add(key);
                }
            }
            
            const startKey = `${startPos.row},${startPos.col}`;
            distances.set(startKey, 0);
            
            highlightLine(0); // dijkstra function start
            await pause();
            
            highlightLine(1); // distances[start] = 0
            await pause();
            
            while (unvisited.size > 0 && !stopSorting) {
                highlightLine(3); // while priority_queue not empty
                
                // Find unvisited node with minimum distance
                let current = null;
                let minDistance = Infinity;
                
                for (const nodeKey of unvisited) {
                    if (distances.get(nodeKey) < minDistance) {
                        minDistance = distances.get(nodeKey);
                        current = nodeKey;
                    }
                }
                
                if (current === null || minDistance === Infinity) break;
                
                const [currentRow, currentCol] = current.split(',').map(Number);
                unvisited.delete(current);
                
                highlightLine(4); // current_dist, current = pop_min
                
                // Mark as visited
                if (grid[currentRow][currentCol] !== GRID_STATES.START && 
                    grid[currentRow][currentCol] !== GRID_STATES.END) {
                    grid[currentRow][currentCol] = GRID_STATES.VISITED;
                }
                drawGrid();
                await pause();
                
                // Check if we reached the end
                if (currentRow === endPos.row && currentCol === endPos.col) {
                    highlightLine(5); // if current == end
                    highlightLine(6); // return path
                    
                    // Reconstruct and draw path
                    const path = [];
                    let pathNode = current;
                    while (previous.has(pathNode)) {
                        const [row, col] = pathNode.split(',').map(Number);
                        path.unshift({ row, col });
                        pathNode = previous.get(pathNode);
                    }
                    
                    // Draw path
                    for (const node of path) {
                        if (grid[node.row][node.col] !== GRID_STATES.START && 
                            grid[node.row][node.col] !== GRID_STATES.END) {
                            grid[node.row][node.col] = GRID_STATES.PATH;
                        }
                    }
                    drawGrid();
                    break;
                }
                
                // Check neighbors
                highlightLine(7); // for neighbor in graph[current]
                const neighbors = getNeighbors(currentRow, currentCol);
                
                for (const neighbor of neighbors) {
                    if (stopSorting) break;
                    
                    const neighborKey = `${neighbor.row},${neighbor.col}`;
                    if (!unvisited.has(neighborKey)) continue;
                    
                    const weight = getNodeWeight(grid[neighbor.row][neighbor.col]);
                    const newDistance = distances.get(current) + weight;
                    
                    highlightLine(8); // new_dist = current_dist + weight
                    
                    if (newDistance < distances.get(neighborKey)) {
                        highlightLine(9); // if new_dist < distances[neighbor]
                        distances.set(neighborKey, newDistance);
                        previous.set(neighborKey, current);
                        
                        highlightLine(10); // distances[neighbor] = new_dist
                        highlightLine(11); // parent[neighbor] = current
                        
                        // Mark as in queue
                        if (grid[neighbor.row][neighbor.col] !== GRID_STATES.START && 
                            grid[neighbor.row][neighbor.col] !== GRID_STATES.END) {
                            grid[neighbor.row][neighbor.col] = GRID_STATES.IN_QUEUE;
                        }
                    }
                }
                drawGrid();
                await pause();
            }
            
            isSorting = false;
            clearHighlights();
            updateMessage(stopSorting ? "Pathfinding stopped!" : "Pathfinding complete!");
        }
        
        // A* Algorithm Implementation
        async function astar() {
            clearGrid();
            isSorting = true;
            stopSorting = false;
            
            const gScore = new Map();
            const fScore = new Map();
            const previous = new Map();
            const openSet = new Set();
            const closedSet = new Set();
            
            // Initialize scores
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const key = `${row},${col}`;
                    gScore.set(key, Infinity);
                    fScore.set(key, Infinity);
                }
            }
            
            const startKey = `${startPos.row},${startPos.col}`;
            gScore.set(startKey, 0);
            fScore.set(startKey, heuristic(startPos, endPos));
            openSet.add(startKey);
            
            highlightLine(0); // astar function start
            await pause();
            
            highlightLine(1); // g_score[start] = 0
            await pause();
            
            highlightLine(2); // f_score[start] = heuristic
            await pause();
            
            while (openSet.size > 0 && !stopSorting) {
                highlightLine(4); // while open_set not empty
                
                // Find node in openSet with lowest fScore
                let current = null;
                let minFScore = Infinity;
                
                for (const nodeKey of openSet) {
                    if (fScore.get(nodeKey) < minFScore) {
                        minFScore = fScore.get(nodeKey);
                        current = nodeKey;
                    }
                }
                
                const [currentRow, currentCol] = current.split(',').map(Number);
                
                highlightLine(5); // current = pop_min(open_set)
                
                if (currentRow === endPos.row && currentCol === endPos.col) {
                    highlightLine(6); // if current == end
                    highlightLine(7); // return reconstruct_path
                    
                    // Reconstruct and draw path
                    const path = [];
                    let pathNode = current;
                    while (previous.has(pathNode)) {
                        const [row, col] = pathNode.split(',').map(Number);
                        path.unshift({ row, col });
                        pathNode = previous.get(pathNode);
                    }
                    
                    // Draw path
                    for (const node of path) {
                        if (grid[node.row][node.col] !== GRID_STATES.START && 
                            grid[node.row][node.col] !== GRID_STATES.END) {
                            grid[node.row][node.col] = GRID_STATES.PATH;
                        }
                    }
                    drawGrid();
                    break;
                }
                
                openSet.delete(current);
                closedSet.add(current);
                
                // Mark as visited
                if (grid[currentRow][currentCol] !== GRID_STATES.START && 
                    grid[currentRow][currentCol] !== GRID_STATES.END) {
                    grid[currentRow][currentCol] = GRID_STATES.VISITED;
                }
                drawGrid();
                await pause();
                
                // Check neighbors
                highlightLine(8); // for neighbor in graph[current]
                const neighbors = getNeighbors(currentRow, currentCol);
                
                for (const neighbor of neighbors) {
                    if (stopSorting) break;
                    
                    const neighborKey = `${neighbor.row},${neighbor.col}`;
                    if (closedSet.has(neighborKey)) continue;
                    
                    const weight = getNodeWeight(grid[neighbor.row][neighbor.col]);
                    const tentativeGScore = gScore.get(current) + weight;
                    
                    highlightLine(9); // tentative_g = g_score[current] + weight
                    
                    if (tentativeGScore < gScore.get(neighborKey)) {
                        highlightLine(10); // if tentative_g < g_score[neighbor]
                        
                        previous.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + heuristic(neighbor, endPos));
                        
                        highlightLine(11); // g_score[neighbor] = tentative_g
                        highlightLine(12); // f_score[neighbor] = tentative_g + heuristic
                        
                        if (!openSet.has(neighborKey)) {
                            openSet.add(neighborKey);
                            
                            // Mark as in queue
                            if (grid[neighbor.row][neighbor.col] !== GRID_STATES.START && 
                                grid[neighbor.row][neighbor.col] !== GRID_STATES.END) {
                                grid[neighbor.row][neighbor.col] = GRID_STATES.IN_QUEUE;
                            }
                        }
                    }
                }
                drawGrid();
                await pause();
            }
            
            isSorting = false;
            clearHighlights();
            updateMessage(stopSorting ? "Pathfinding stopped!" : "Pathfinding complete!");
        }
        
        // Heuristic function for A* (Manhattan distance)
        function heuristic(nodeA, nodeB) {
            return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);
        }

        // Tree-based traversal algorithms
        const treeCanvas = document.getElementById('treeCanvas');
        const tCtx = treeCanvas ? treeCanvas.getContext('2d') : null;
        
        // Tree structure
        let tree = null;
        let visitedNodes = new Set();
        let currentNode = null;
        let traversalOrder = [];
        
        // Tree node class
        class TreeNode {
            constructor(value, x, y) {
                this.value = value;
                this.x = x;
                this.y = y;
                this.left = null;
                this.right = null;
                this.visited = false;
                this.current = false;
                this.radius = 25;
            }
        }
        
        function createTree() {
            // Create a binary tree with 3 levels (like in the image)
            tree = new TreeNode(0, 400, 80); // Root at center top
            
            // Level 1: Children of root
            tree.left = new TreeNode(1, 250, 180);
            tree.right = new TreeNode(2, 550, 180);
            
            // Level 2: Children of level 1
            tree.left.left = new TreeNode(3, 150, 280);
            tree.left.right = new TreeNode(4, 350, 280);
            tree.right.left = new TreeNode(5, 450, 280);
            tree.right.right = new TreeNode(6, 650, 280);
            
            // Level 3: Children of level 2 (some are leaves)
            tree.left.left.left = new TreeNode(7, 100, 380);
            tree.left.left.right = new TreeNode(8, 200, 380);
            tree.left.right.left = new TreeNode(9, 300, 380);
            tree.left.right.right = new TreeNode(10, 400, 380);
            // Nodes 5 and 6 are leaves (no children)
            
            drawTree();
        }
        
        function drawTree() {
            if (!tCtx) return;
            
            tCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);
            
            // Draw title
            tCtx.fillStyle = '#9C27B0';
            tCtx.font = 'bold 18px Segoe UI';
            tCtx.textAlign = 'center';
            tCtx.fillText('Tree Traversal Visualization', treeCanvas.width / 2, 30);
            
            // Draw tree recursively
            drawTreeNode(tree);
            
            // Draw traversal order
            drawTraversalOrder();
        }
        
        function drawTreeNode(node) {
            if (!node) return;
            
            // Draw connections to children first (so they appear behind nodes)
            if (node.left) {
                tCtx.strokeStyle = '#666666';
                tCtx.lineWidth = 2;
                tCtx.beginPath();
                tCtx.moveTo(node.x, node.y + node.radius);
                tCtx.lineTo(node.left.x, node.left.y - node.left.radius);
                tCtx.stroke();
                drawTreeNode(node.left);
            }
            
            if (node.right) {
                tCtx.strokeStyle = '#666666';
                tCtx.lineWidth = 2;
                tCtx.beginPath();
                tCtx.moveTo(node.x, node.y + node.radius);
                tCtx.lineTo(node.right.x, node.right.y - node.right.radius);
                tCtx.stroke();
                drawTreeNode(node.right);
            }
            
            // Draw node
            let nodeColor = '#4A148C'; // Default purple
            if (node.visited) {
                nodeColor = '#2196F3'; // Blue for visited
            }
            if (node.current) {
                nodeColor = '#FF9800'; // Orange for current
            }
            
            // Node circle
            tCtx.fillStyle = nodeColor;
            tCtx.beginPath();
            tCtx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
            tCtx.fill();
            
            // Node border
            tCtx.strokeStyle = '#FFFFFF';
            tCtx.lineWidth = 2;
            tCtx.stroke();
            
            // Node value
            tCtx.fillStyle = '#FFFFFF';
            tCtx.font = 'bold 16px Segoe UI';
            tCtx.textAlign = 'center';
            tCtx.fillText(node.value.toString(), node.x, node.y + 6);
        }
        
        function drawTraversalOrder() {
            if (traversalOrder.length === 0) return;
            
            tCtx.fillStyle = '#E0E0E0';
            tCtx.font = '14px Segoe UI';
            tCtx.textAlign = 'left';
            
            let orderText = 'Traversal Order: ';
            for (let i = 0; i < traversalOrder.length; i++) {
                orderText += traversalOrder[i];
                if (i < traversalOrder.length - 1) {
                    orderText += ' → ';
                }
            }
            
            tCtx.fillText(orderText, 20, treeCanvas.height - 20);
        }
        
        function resetTree() {
            visitedNodes.clear();
            currentNode = null;
            traversalOrder = [];
            resetTreeNode(tree);
            drawTree();
        }
        
        function resetTreeNode(node) {
            if (!node) return;
            node.visited = false;
            node.current = false;
            resetTreeNode(node.left);
            resetTreeNode(node.right);
        }
        
        // Tree DFS Algorithm
        async function treeDfsTraversal() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            
            updateMessage(`🌳 Starting Tree DFS traversal...`);
            await pause();
            
            resetTree();
            traversalOrder = [];
            
            await dfsTraverse(tree);
            
            updateMessage(`🎉 Tree DFS completed! Traversal order: ${traversalOrder.join(' → ')}`);
            
            isSorting = false;
            stopBtn.disabled = true;
        }
        
        async function dfsTraverse(node) {
            if (!node || stopSorting) return;
            
            // Mark current node as being explored
            node.current = true;
            currentNode = node;
            drawTree();
            
            updateMessage(`🔍 DFS visiting node ${node.value}...`);
            await pause();
            
            // Mark as visited and add to traversal order
            node.visited = true;
            node.current = false;
            visitedNodes.add(node.value);
            traversalOrder.push(node.value);
            drawTree();
            
            updateMessage(`✅ Node ${node.value} visited. Traversal order: ${traversalOrder.join(' → ')}`);
            await pause();
            
            // Recursively traverse left subtree
            if (node.left && !stopSorting) {
                updateMessage(`⬅️ Going to left child of ${node.value}...`);
                await pause();
                await dfsTraverse(node.left);
            }
            
            // Recursively traverse right subtree
            if (node.right && !stopSorting) {
                updateMessage(`➡️ Going to right child of ${node.value}...`);
                await pause();
                await dfsTraverse(node.right);
            }
            
            if (!stopSorting) {
                updateMessage(`🔙 Backtracking from node ${node.value}...`);
                await pause();
            }
        }
        
        // Tree BFS Algorithm
        async function treeBfsTraversal() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            
            updateMessage(`🌳 Starting Tree BFS traversal...`);
            await pause();
            
            resetTree();
            traversalOrder = [];
            
            const queue = [tree];
            
            while (queue.length > 0 && !stopSorting) {
                const node = queue.shift(); // FIFO - First In, First Out
                
                // Mark current node as being explored
                node.current = true;
                currentNode = node;
                drawTree();
                
                updateMessage(`🔍 BFS visiting node ${node.value}...`);
                await pause();
                
                // Mark as visited and add to traversal order
                node.visited = true;
                node.current = false;
                visitedNodes.add(node.value);
                traversalOrder.push(node.value);
                drawTree();
                
                updateMessage(`✅ Node ${node.value} visited. Traversal order: ${traversalOrder.join(' → ')}`);
                await pause();
                
                // Add children to queue (left to right)
                if (node.left) {
                    queue.push(node.left);
                }
                if (node.right) {
                    queue.push(node.right);
                }
                
                if (queue.length > 0 && !stopSorting) {
                    updateMessage(`📋 Queue: [${queue.map(n => n.value).join(', ')}]`);
                    await pause();
                }
            }
            
            updateMessage(`🎉 Tree BFS completed! Traversal order: ${traversalOrder.join(' → ')}`);
            
            isSorting = false;
            stopBtn.disabled = true;
        }

        function initializeData() {
            // Clear history when initializing new data
            clearHistory();
            
            if (pathfindingAlgos.has(selectedAlgorithm)) {
                // Initialize grid for pathfinding algorithms
                initializeGrid();
                isSorting = false;
                startBtn.disabled = false;
                updatePseudocode();
                messageEl.textContent = 'Ready to find path. Press Start.';
            } else if (treeAlgos.has(selectedAlgorithm)) {
                // Initialize tree for tree traversal algorithms
                createTree();
                isSorting = false;
                startBtn.disabled = false;
                updatePseudocode();
                messageEl.textContent = 'Ready to traverse tree. Press Start.';
            } else {
                if (useExampleData) {
                    originalValues = [...exampleData];
                    const maxVal = Math.max(...exampleData);
                    data = exampleData.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
                } else {
                    originalValues = [];
                    data = [];
                    for (let k = 0; k < NUM_BARS; k++) {
                        const value = Math.floor(Math.random() * 350) + 10;
                        originalValues.push(value);
                        data.push(value);
                    }
                }
                isSorting = false;
                startBtn.disabled = false;
                drawBars();
                if (searchAlgos.has(selectedAlgorithm)) drawSearchCanvas({});
                updatePseudocode();
                messageEl.textContent = 'Ready to visualize. Press Start.';
            }
        }

        async function pause() {
            const speed = parseInt(speedSelect.value, 10);
            // wait in small increments so pause can be toggled responsively
            const step = Math.max(20, Math.floor(speed / 8));
            let waited = 0;
            while (waited < speed) {
                if (stopSorting) break;
                while (isPaused) {
                    // while paused, surface the last condition into the message box
                    try {
                        if (messageEl) {
                            messageEl.textContent = lastConditionDetail || 'Paused — waiting at current check...';
                        }
                    } catch (e) {
                        // ignore
                    }
                    await new Promise(r => setTimeout(r, 150));
                    if (stopSorting) break;
                }
                await new Promise(r => setTimeout(r, step));
                waited += step;
            }
        }

        function updateMessage(text) {
            messageEl.textContent = text;
        }

        // Performance metrics functions
        function resetPerformanceMetrics() {
            totalComparisons = 0;
            totalSwaps = 0;
            startTime = Date.now();
            timeElapsed = 0;
            updatePerformanceDisplay();
        }

        function incrementComparisons() {
            totalComparisons++;
            updatePerformanceDisplay();
        }

        function incrementSwaps() {
            totalSwaps++;
            updatePerformanceDisplay();
        }

        function updatePerformanceDisplay() {
            document.getElementById('comparisonsCount').textContent = totalComparisons;
            document.getElementById('swapsCount').textContent = totalSwaps;
            if (startTime > 0) {
                timeElapsed = Date.now() - startTime;
                document.getElementById('timeElapsed').textContent = timeElapsed + 'ms';
            }
        }

        function startPerformanceTracking() {
            resetPerformanceMetrics();
            // Update time every 100ms during sorting
            performanceUpdateInterval = setInterval(() => {
                if (isSorting) {
                    updatePerformanceDisplay();
                }
            }, 100);
        }

        function stopPerformanceTracking() {
            if (performanceUpdateInterval) {
                clearInterval(performanceUpdateInterval);
                performanceUpdateInterval = null;
            }
            updatePerformanceDisplay(); // Final update
            
            // Show summary modal after a short delay if algorithm completed successfully
            if (!stopSorting) {
                setTimeout(() => {
                    showSummary();
                }, 500);
            }
        }

        // Summary and Comparison Functions
        let comparisonData = [];
        
        // Load existing comparison data from localStorage
        function loadComparisonData() {
            try {
                const stored = localStorage.getItem('algorithmComparisons');
                if (stored) {
                    comparisonData = JSON.parse(stored);
                    updateComparisonPanel();
                }
            } catch (e) {
                console.error('Error loading comparison data:', e);
                comparisonData = [];
            }
        }

        function showSummary() {
            const algorithmNames = {
                bubbleSort: 'Bubble Sort',
                insertionSort: 'Insertion Sort',
                selectionSort: 'Selection Sort',
                quickSort: 'Quick Sort',
                mergeSort: 'Merge Sort',
                linearSearch: 'Linear Search',
                binarySearch: 'Binary Search',
                insertMethod: 'Insert Method',
                deleteMethod: 'Delete Method'
            };

            document.getElementById('summaryAlgorithmName').textContent = algorithmNames[selectedAlgorithm] || selectedAlgorithm;
            document.getElementById('summaryInputSize').textContent = data.length;
            document.getElementById('summaryComparisons').textContent = totalComparisons;
            document.getElementById('summarySwaps').textContent = totalSwaps;
            document.getElementById('summaryTime').textContent = timeElapsed;
            
            document.getElementById('summaryModal').style.display = 'block';
        }

        function closeSummary() {
            document.getElementById('summaryModal').style.display = 'none';
        }

        function runAgain() {
            closeSummary();
            // Reset and regenerate data
            generateData();
        }

        function addToComparison() {
            const algorithmNames = {
                bubbleSort: 'Bubble Sort',
                insertionSort: 'Insertion Sort',
                selectionSort: 'Selection Sort',
                quickSort: 'Quick Sort',
                mergeSort: 'Merge Sort',
                linearSearch: 'Linear Search',
                binarySearch: 'Binary Search',
                insertMethod: 'Insert Method',
                deleteMethod: 'Delete Method'
            };

            const result = {
                algorithm: algorithmNames[selectedAlgorithm] || selectedAlgorithm,
                inputSize: data.length,
                comparisons: totalComparisons,
                swaps: totalSwaps,
                time: timeElapsed,
                timestamp: new Date().toLocaleTimeString()
            };

            comparisonData.push(result);
            
            // Save to localStorage for persistence
            try {
                localStorage.setItem('algorithmComparisons', JSON.stringify(comparisonData));
            } catch (e) {
                console.error('Error saving comparison data:', e);
            }
            
            updateComparisonPanel();
            closeSummary();
            
            // Show success message with link to detailed comparison
            updateMessage(`✅ ${result.algorithm} added to comparison! <a href="comparison.html" style="color: #00ffff;">View detailed analysis</a>`);
        }

        function toggleComparisonPanel() {
            const panel = document.getElementById('comparisonPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        }

        function updateComparisonPanel() {
            const list = document.getElementById('comparisonList');
            
            if (comparisonData.length === 0) {
                list.innerHTML = `
                    <p style="color: #a0a0a0; text-align: center; margin: 50px 0;">
                        No algorithms compared yet.<br>
                        Run algorithms and add them to comparison!
                    </p>
                `;
                return;
            }

            list.innerHTML = comparisonData.map((item, index) => `
                <div class="comparison-item">
                    <div class="comparison-item-title">
                        ${item.algorithm} 
                        <span style="font-size: 0.8em; color: #666;">(${item.timestamp})</span>
                        <button style="float: right; background: none; border: none; color: #ff4444; cursor: pointer;" onclick="removeComparison(${index})">🗑️</button>
                    </div>
                    <div class="comparison-item-stats">
                        <div class="comparison-stat">Input Size: <span class="comparison-stat-value">${item.inputSize}</span></div>
                        <div class="comparison-stat">Time: <span class="comparison-stat-value">${item.time}ms</span></div>
                        <div class="comparison-stat">Comparisons: <span class="comparison-stat-value">${item.comparisons}</span></div>
                        <div class="comparison-stat">Swaps/Moves: <span class="comparison-stat-value">${item.swaps}</span></div>
                    </div>
                </div>
            `).join('');
        }

        function removeComparison(index) {
            comparisonData.splice(index, 1);
            updateComparisonPanel();
        }

        function clearComparisons() {
            comparisonData = [];
            updateComparisonPanel();
        }

        // State management functions for reversible control
        function captureState(description = '') {
            const state = {
                data: [...data],
                originalValues: [...originalValues],
                description: description,
                timestamp: Date.now()
            };
            
            // Add algorithm-specific state variables if they exist
            if (currentAlgorithmState) {
                state.algorithmState = { ...currentAlgorithmState };
            }
            
            historyStack.push(state);
            
            // Clear future states when new action is taken
            futureStates = [];
            
            // Update button states
            updateStepButtons();
        }

        function restoreState(state) {
            if (!state) return false;
            
            data = [...state.data];
            originalValues = [...state.originalValues];
            
            // Restore algorithm-specific state if it exists
            if (state.algorithmState) {
                currentAlgorithmState = { ...state.algorithmState };
            }
            
            drawBars();
            if (searchAlgos.has(selectedAlgorithm)) drawSearchCanvas({});
            updateMessage(`Restored: ${state.description}`);
            
            return true;
        }

        function stepBackward() {
            if (historyStack.length === 0) return false;
            
            // Save current state to future states
            const currentState = {
                data: [...data],
                originalValues: [...originalValues],
                description: 'Current state',
                timestamp: Date.now()
            };
            
            if (currentAlgorithmState) {
                currentState.algorithmState = { ...currentAlgorithmState };
            }
            
            futureStates.push(currentState);
            
            // Restore previous state
            const previousState = historyStack.pop();
            restoreState(previousState);
            
            updateStepButtons();
            return true;
        }

        function stepForward() {
            if (futureStates.length === 0) return false;
            
            // Save current state to history (without using captureState to avoid clearing futureStates)
            const currentState = {
                data: [...data],
                originalValues: [...originalValues],
                description: 'Before forward step',
                timestamp: Date.now()
            };
            
            if (currentAlgorithmState) {
                currentState.algorithmState = { ...currentAlgorithmState };
            }
            
            historyStack.push(currentState);
            
            // Restore future state
            const futureState = futureStates.pop();
            restoreState(futureState);
            
            updateStepButtons();
            return true;
        }

        function updateStepButtons() {
            if (stepBackwardBtn) {
                stepBackwardBtn.disabled = historyStack.length === 0 || isSorting;
            }
            if (stepForwardBtn) {
                stepForwardBtn.disabled = futureStates.length === 0 || isSorting;
            }
        }

        function clearHistory() {
            historyStack = [];
            futureStates = [];
            currentAlgorithmState = null;
            updateStepButtons();
        }

        function updatePseudocode() {
            const code = pseudocodes[selectedAlgorithm];
            if (Array.isArray(code)) {
                // Create line-by-line structure for highlighting
                pseudocodeEl.innerHTML = '';
                code.forEach((line, index) => {
                    const lineEl = document.createElement('div');
                    lineEl.className = 'code-line';
                    lineEl.id = `code-line-${index}`;
                    lineEl.textContent = line || ' '; // Empty lines get a space
                    pseudocodeEl.appendChild(lineEl);
                });
            } else {
                // Fallback for old string format
                pseudocodeEl.textContent = code || '';
            }
        }

        // Live Code Highlighting Functions
        function highlightLine(lineNumber, type = 'highlighted') {
            // Clear previous highlights
            clearHighlights();
            
            // Highlight the specified line
            const lineEl = document.getElementById(`code-line-${lineNumber}`);
            if (lineEl) {
                lineEl.classList.add(type);
                
                // Scroll the line into view if needed
                lineEl.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center',
                    inline: 'nearest'
                });
            }
        }

        function clearHighlights() {
            const lines = document.querySelectorAll('.code-line');
            lines.forEach(line => {
                line.classList.remove('highlighted', 'executing');
            });
        }

        function highlightExecutingLine(lineNumber) {
            highlightLine(lineNumber, 'executing');
        }

        async function bubbleSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            clearHistory(); // Clear previous history when starting new sort
            updateStepButtons();
            startPerformanceTracking(); // Start tracking performance metrics
            const currentNumBars = data.length;
            
            // Capture initial state
            captureState('Initial state');
            highlightLine(0);
            
            // Highlight outer loop line
            highlightLine(0);
            for (let i = 0; i < currentNumBars && !stopSorting; i++) {
                // Capture state at start of each pass
                currentAlgorithmState = { i, j: -1, pass: i + 1 };
                captureState(`Pass ${i + 1} started`);
                
                updateMessage(`Outer loop: Pass ${i + 1}/${currentNumBars}.`);
                await pause();
                
                // Highlight inner loop line
                highlightLine(1);
                for (let j = 0; j < currentNumBars - i - 1 && !stopSorting; j++) {
                    // Update algorithm state for current comparison
                    currentAlgorithmState = { i, j, pass: i + 1 };
                    captureState(`Comparing indices ${j} and ${j + 1}`);
                    
                    // Highlight comparison line
                    highlightLine(2);
                    drawBars(j, j + 1);
                    const cond = originalValues[j] > originalValues[j + 1];
                    incrementComparisons(); // Track comparison
                    lastConditionDetail = `Comparing index ${j} (${originalValues[j]}) > index ${j+1} (${originalValues[j+1]}) ? ${cond ? 'true' : 'false'}`;
                    updateMessage(`Comparing elements at index ${j} (${originalValues[j]}) and ${j + 1} (${originalValues[j + 1]}). Condition (a > b): ${cond ? 'true' : 'false'}.`);
                    await pause();
                    
                    if (data[j] > data[j + 1]) {
                        // Capture state before swap
                        captureState(`Before swap: ${originalValues[j]} and ${originalValues[j + 1]}`);
                        
                        // Highlight swap line
                        highlightLine(3);
                        [data[j], data[j + 1]] = [data[j + 1], data[j]];
                        [originalValues[j], originalValues[j + 1]] = [originalValues[j + 1], originalValues[j]];
                        incrementSwaps(); // Track swap
                        
                        drawBars(j, j + 1);
                        updateMessage(`Swapping elements at index ${j} and ${j + 1}.`);
                        await pause();
                    }
                }
            }
            
            isSorting = false;
            stopBtn.disabled = true;
            stopPerformanceTracking(); // Stop tracking performance metrics
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
            clearHighlights(); // Clear code highlighting when algorithm completes
            updateStepButtons(); // Re-enable step buttons after sorting completes
        }

        async function insertionSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            clearHistory(); // Clear previous history when starting new sort
            updateStepButtons();
            startPerformanceTracking(); // Start tracking performance metrics
            const currentNumBars = data.length;
            
            // Capture initial state
            captureState('Initial state');
            
            // Highlight outer loop line
            highlightLine(0);
            for (let i = 1; i < currentNumBars && !stopSorting; i++) {
                // Highlight key selection line
                highlightLine(1);
                let current = data[i];
                let currentVal = originalValues[i];
                
                // Highlight j initialization line
                highlightLine(2);
                let j = i - 1;
                
                // Capture state when selecting key
                currentAlgorithmState = { i, j, current: currentVal, keyIndex: i };
                captureState(`Selected key: ${currentVal} at index ${i}`);
                
                updateMessage(`Taking element at index ${i} (${currentVal}) as key.`);
                await pause();
                
                // Highlight while loop condition line
                highlightLine(3);
                while (j >= 0 && data[j] > current && !stopSorting) {
                    const cond = originalValues[j] > currentVal;
                    incrementComparisons(); // Track comparison
                    lastConditionDetail = `Is index ${j} value ${originalValues[j]} > key ${currentVal}? ${cond ? 'true' : 'false'}`;
                    
                    // Capture state before shift
                    currentAlgorithmState = { i, j, current: currentVal, keyIndex: i, shifting: true };
                    captureState(`Before shift: moving ${originalValues[j]} from index ${j} to ${j + 1}`);
                    
                    // Highlight array shift line
                    highlightLine(4);
                    data[j + 1] = data[j];
                    originalValues[j + 1] = originalValues[j];
                    incrementSwaps(); // Track move/shift operation
                    
                    // Highlight j decrement line
                    highlightLine(5);
                    j = j - 1;
                    drawBars(j + 1, i);
                    updateMessage(`Condition (a > key) is ${cond ? 'true' : 'false'} — shifting element at index ${j + 1} to the right.`);
                    await pause();
                    
                    // Re-highlight while condition for next iteration
                    highlightLine(3);
                }
                
                // Capture state before inserting key
                currentAlgorithmState = { i, j, current: currentVal, keyIndex: i, inserting: true };
                captureState(`Inserting key ${currentVal} at position ${j + 1}`);
                
                // Highlight key insertion line
                highlightLine(6);
                data[j + 1] = current;
                originalValues[j + 1] = currentVal;
                incrementSwaps(); // Track key insertion move
                drawBars(i, j + 1);
                await pause();
            }
            
            isSorting = false;
            stopBtn.disabled = true;
            stopPerformanceTracking(); // Stop tracking performance metrics
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
            clearHighlights(); // Clear code highlighting when algorithm completes
            updateStepButtons(); // Re-enable step buttons after sorting completes
        }

        async function selectionSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            clearHistory(); // Clear previous history when starting new sort
            updateStepButtons();
            startPerformanceTracking(); // Start tracking performance metrics
            const currentNumBars = data.length;
            
            // Capture initial state
            captureState('Initial state');
            
            for (let i = 0; i < currentNumBars && !stopSorting; i++) {
                let minIndex = i;
                
                // Capture state at start of each pass
                currentAlgorithmState = { i, minIndex, pass: i + 1 };
                captureState(`Pass ${i + 1}: Finding minimum from index ${i}`);
                
                updateMessage(`Finding minimum element from index ${i} to ${currentNumBars-1}`);
                await pause();
                
                for (let j = i + 1; j < currentNumBars && !stopSorting; j++) {
                    // Update algorithm state for current comparison
                    currentAlgorithmState = { i, j, minIndex, pass: i + 1 };
                    captureState(`Comparing index ${j} with current minimum at ${minIndex}`);
                    
                    drawBars(minIndex, j);
                    const cond = originalValues[j] < originalValues[minIndex];
                    incrementComparisons(); // Track comparison
                    lastConditionDetail = `Is index ${j} value ${originalValues[j]} < current min index ${minIndex} value ${originalValues[minIndex]}? ${cond ? 'true' : 'false'}`;
                    updateMessage(`Comparing ${originalValues[j]} with current minimum ${originalValues[minIndex]}. Condition (a < min): ${cond ? 'true' : 'false'}.`);
                    await pause();
                    
                    if (data[j] < data[minIndex]) {
                        // Capture state before updating minimum
                        captureState(`New minimum found: ${originalValues[j]} at index ${j}`);
                        
                        minIndex = j;
                        drawBars(minIndex, j);
                        updateMessage(`New minimum found: ${originalValues[minIndex]}`);
                        await pause();
                    }
                }
                
                if (minIndex !== i) {
                    // Capture state before swap
                    captureState(`Before swap: ${originalValues[i]} and ${originalValues[minIndex]}`);
                    
                    [data[i], data[minIndex]] = [data[minIndex], data[i]];
                    [originalValues[i], originalValues[minIndex]] = [originalValues[minIndex], originalValues[i]];
                    incrementSwaps(); // Track swap
                    drawBars(i, minIndex);
                    updateMessage(`Swapping ${originalValues[i]} to position ${i}`);
                    await pause();
                }
            }
            
            isSorting = false;
            stopBtn.disabled = true;
            stopPerformanceTracking(); // Stop tracking performance metrics
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
            updateStepButtons(); // Re-enable step buttons after sorting completes
        }

        async function quickSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            clearHistory(); // Clear previous history when starting new sort
            updateStepButtons();
            startPerformanceTracking(); // Start tracking performance metrics
            
            // Capture initial state
            captureState('Initial state');
            highlightLine(0);

            async function partition(low, high) {
                const pivot = data[high];
                const pivotVal = originalValues[high];
                let i = low - 1;
                highlightLine(7);
                highlightLine(8);
                
                // Capture state at start of partition
                currentAlgorithmState = { low, high, pivot: pivotVal, i, partitioning: true };
                captureState(`Partitioning range [${low}, ${high}] with pivot ${pivotVal}`);
                
                updateMessage(`Partitioning around pivot ${pivotVal}`);
                await pause();
                
                highlightLine(9);
                for (let j = low; j < high && !stopSorting; j++) {
                    // Update algorithm state for current comparison
                    currentAlgorithmState = { low, high, pivot: pivotVal, i, j, partitioning: true };
                    captureState(`Comparing ${originalValues[j]} with pivot ${pivotVal}`);
                    
                    drawBars(j, high);
                    const cond = originalValues[j] <= pivotVal;
                    incrementComparisons(); // Track comparison
                    lastConditionDetail = `Is index ${j} value ${originalValues[j]} <= pivot ${pivotVal}? ${cond ? 'true' : 'false'}`;
                    updateMessage(`Comparing ${originalValues[j]} with pivot ${pivotVal}. Condition (a <= pivot): ${cond ? 'true' : 'false'}.`);
                    highlightLine(10);
                    await pause();
                    
                    if (data[j] <= pivot) {
                        highlightLine(11);
                        i++;
                        // Capture state before swap
                        captureState(`Before swap in partition: ${originalValues[i]} and ${originalValues[j]}`);
                        
                        highlightLine(12);
                        [data[i], data[j]] = [data[j], data[i]];
                        [originalValues[i], originalValues[j]] = [originalValues[j], originalValues[i]];
                        incrementSwaps(); // Track swap
                        drawBars(i, j);
                        updateMessage(`Swapping elements: ${originalValues[i]} and ${originalValues[j]}`);
                        await pause();
                    }
                }
                
                // Capture state before final pivot placement
                captureState(`Placing pivot ${originalValues[high]} in final position ${i + 1}`);
                highlightLine(13);
                
                [data[i + 1], data[high]] = [data[high], data[i + 1]];
                [originalValues[i + 1], originalValues[high]] = [originalValues[high], originalValues[i + 1]];
                incrementSwaps(); // Track pivot placement swap
                drawBars(i + 1, high);
                await pause();
                
                highlightLine(14);
                return i + 1;
            }

            async function quickSortRecursive(low, high) {
                highlightLine(1);
                if (low < high && !stopSorting) {
                    // Capture state before recursive call
                    currentAlgorithmState = { low, high, recursive: true };
                    captureState(`Recursively sorting range [${low}, ${high}]`);
                    
                    highlightLine(2);
                    const pi = await partition(low, high);
                    highlightLine(3);
                    await quickSortRecursive(low, pi - 1);
                    highlightLine(4);
                    await quickSortRecursive(pi + 1, high);
                }
            }

            await quickSortRecursive(0, data.length - 1);
            
            isSorting = false;
            stopBtn.disabled = true;
            stopPerformanceTracking(); // Stop tracking performance metrics
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
            updateStepButtons(); // Re-enable step buttons after sorting completes
        }

        async function mergeSort() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            clearHistory(); // Clear previous history when starting new sort
            updateStepButtons();
            startPerformanceTracking(); // Start tracking performance metrics
            
            // Capture initial state
            captureState('Initial state');
            highlightLine(0);

            async function merge(left, mid, right) {
                highlightLine(7);
                // Capture state at start of merge
                currentAlgorithmState = { left, mid, right, merging: true };
                captureState(`Merging ranges [${left}, ${mid}] and [${mid + 1}, ${right}]`);
                
                const leftArray = data.slice(left, mid + 1);
                const rightArray = data.slice(mid + 1, right + 1);
                const leftOriginal = originalValues.slice(left, mid + 1);
                const rightOriginal = originalValues.slice(mid + 1, right + 1);
                highlightLine(8);
                highlightLine(9);
                
                let i = 0, j = 0, k = left;
                
                while (i < leftArray.length && j < rightArray.length && !stopSorting) {
                    // Update algorithm state for current comparison
                    currentAlgorithmState = { left, mid, right, i, j, k, merging: true };
                    captureState(`Comparing ${leftOriginal[i]} with ${rightOriginal[j]} for position ${k}`);
                    
                    drawBars(left + i, mid + 1 + j);
                    const cond = leftOriginal[i] <= rightOriginal[j];
                    incrementComparisons(); // Track comparison
                    lastConditionDetail = `Compare left ${leftOriginal[i]} <= right ${rightOriginal[j]} ? ${cond ? 'true' : 'false'}`;
                    updateMessage(`Comparing ${leftOriginal[i]} with ${rightOriginal[j]}. Condition (left <= right): ${cond ? 'true' : 'false'}.`);
                    highlightLine(10);
                    await pause();
                    
                    if (leftArray[i] <= rightArray[j]) {
                        // Capture state before placing left element
                        captureState(`Placing ${leftOriginal[i]} from left array at position ${k}`);
                        data[k] = leftArray[i];
                        originalValues[k] = leftOriginal[i];
                        incrementSwaps(); // Track move operation
                        i++;
                    } else {
                        // Capture state before placing right element
                        captureState(`Placing ${rightOriginal[j]} from right array at position ${k}`);
                        data[k] = rightArray[j];
                        originalValues[k] = rightOriginal[j];
                        incrementSwaps(); // Track move operation
                        j++;
                    }
                    drawBars(k);
                    await pause();
                    k++;
                }
                
                while (i < leftArray.length && !stopSorting) {
                    // Capture state before placing remaining left elements
                    captureState(`Placing remaining left element ${leftOriginal[i]} at position ${k}`);
                    highlightLine(10);
                    data[k] = leftArray[i];
                    originalValues[k] = leftOriginal[i];
                    incrementSwaps(); // Track move operation
                    drawBars(k);
                    await pause();
                    i++;
                    k++;
                }
                
                while (j < rightArray.length && !stopSorting) {
                    // Capture state before placing remaining right elements
                    captureState(`Placing remaining right element ${rightOriginal[j]} at position ${k}`);
                    highlightLine(10);
                    data[k] = rightArray[j];
                    originalValues[k] = rightOriginal[j];
                    incrementSwaps(); // Track move operation
                    drawBars(k);
                    await pause();
                    j++;
                    k++;
                }
            }

            async function mergeSortRecursive(left, right) {
                highlightLine(1);
                if (left < right && !stopSorting) {
                    const mid = Math.floor((left + right) / 2);
                    
                    // Capture state before recursive division
                    currentAlgorithmState = { left, right, mid, dividing: true };
                    captureState(`Dividing range [${left}, ${right}] at midpoint ${mid}`);
                    
                    updateMessage(`Dividing array from index ${left} to ${right}`);
                    highlightLine(2);
                    await pause();
                    
                    highlightLine(3);
                    await mergeSortRecursive(left, mid);
                    highlightLine(4);
                    await mergeSortRecursive(mid + 1, right);
                    highlightLine(5);
                    await merge(left, mid, right);
                }
            }

            await mergeSortRecursive(0, data.length - 1);
            
            isSorting = false;
            stopBtn.disabled = true;
            stopPerformanceTracking(); // Stop tracking performance metrics
            drawBars();
            updateMessage(stopSorting ? "Sorting stopped!" : "Sorting complete!");
            updateStepButtons(); // Re-enable step buttons after sorting completes
        }

        // Insert method algorithm with enhanced visualization
        async function insertMethod() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            
            const targetRaw = document.getElementById('target-input').value.trim();
            const target = parseInt(targetRaw, 10);
            if (isNaN(target)) {
                updateMessage('Please enter a numeric value to insert.');
                isSorting = false;
                stopBtn.disabled = true;
                return;
            }

            // Determine insert position: use user-provided position if valid, otherwise append to end
            let insertPosition;
            if (positionInput && positionInput.value !== '') {
                const pos = parseInt(positionInput.value, 10);
                if (isNaN(pos)) {
                    insertPosition = originalValues.length;
                } else {
                    insertPosition = Math.max(0, Math.min(originalValues.length, pos));
                }
            } else {
                insertPosition = originalValues.length;
            }

            // Show insertion process with animation
            updateMessage(`📥 Inserting value ${target} at position ${insertPosition}...`);
            await pause();

            // Create a visual effect for insertion
            for (let i = originalValues.length; i > insertPosition; i--) {
                drawBars(insertPosition, i);
                updateMessage(`⬅️ Shifting elements to make room for insertion...`);
                await pause();
            }

            // Insert the value
            originalValues.splice(insertPosition, 0, target);
            const maxVal = Math.max(...originalValues);
            data = originalValues.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
            
            // Highlight the inserted element
            drawBars(insertPosition, -1);
            drawSearchCanvas({ checked: insertPosition });
            updateMessage(`✅ Value ${target} successfully inserted at position ${insertPosition}!`);
            await pause();

            isSorting = false;
            stopBtn.disabled = true;
            drawBars();
            updateMessage(`🎉 Insert operation completed! Array now has ${originalValues.length} elements.`);
        }

        // Delete method algorithm with enhanced visualization
        async function deleteMethod() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            
            const targetRaw = document.getElementById('target-input').value.trim();
            const target = parseInt(targetRaw, 10);
            if (isNaN(target)) {
                updateMessage('Please enter a numeric value to delete.');
                isSorting = false;
                stopBtn.disabled = true;
                return;
            }

            updateMessage(`🔍 Searching for value ${target} to delete...`);
            await pause();

            let deleteIndex = -1;
            for (let i = 0; i < originalValues.length && !stopSorting; i++) {
                drawBars(i, -1);
                drawSearchCanvas({ checked: i });
                const cond = originalValues[i] === target;
                
                lastConditionDetail = `Check index ${i} value ${originalValues[i]} === target ${target} ? ${cond ? 'true' : 'false'}`;
                updateMessage(`🔍 Checking index ${i}: value ${originalValues[i]}. Equals target? ${cond ? '✅ Yes' : '❌ No'}.`);
                await pause();
                
                if (cond) {
                    deleteIndex = i;
                    updateMessage(`🎯 Found value ${target} at index ${i}!`);
                    await pause();
                    break;
                }
            }

            if (deleteIndex !== -1) {
                updateMessage(`🗑️ Deleting value ${target} from position ${deleteIndex}...`);
                await pause();

                // Show deletion process with animation
                drawBars(deleteIndex, -1);
                updateMessage(`⬅️ Removing element and shifting remaining elements...`);
                await pause();

                // Remove the element
                originalValues.splice(deleteIndex, 1);
                
                // Update visualization
                if (originalValues.length > 0) {
                    const maxVal = Math.max(...originalValues);
                    data = originalValues.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
                } else {
                    data = [];
                }
                
                drawBars();
                drawSearchCanvas({});
                updateMessage(`✅ Value ${target} successfully deleted from position ${deleteIndex}!`);
                await pause();
                updateMessage(`🎉 Delete operation completed! Array now has ${originalValues.length} elements.`);
            } else {
                updateMessage(`❌ Value ${target} not found in the array.`);
                drawBars();
                drawSearchCanvas({});
            }
            
            isSorting = false;
            stopBtn.disabled = true;
        }

        // Search algorithm visualizers
        async function linearSearch() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            const targetRaw = document.getElementById('target-input').value.trim();
            const target = parseInt(targetRaw, 10);
            if (isNaN(target)) {
                updateMessage('Please enter a numeric target to search for.');
                isSorting = false;
                stopBtn.disabled = true;
                return;
            }

            for (let i = 0; i < originalValues.length && !stopSorting; i++) {
                drawBars(i, -1);
                drawSearchCanvas({ checked: i });
                const cond = originalValues[i] === target;
                lastConditionDetail = `Check index ${i} value ${originalValues[i]} === target ${target} ? ${cond ? 'true' : 'false'}`;
                updateMessage(`Checking index ${i}: value ${originalValues[i]}. Equals target? ${cond ? 'true' : 'false'}.`);
                await pause();
                if (cond) {
                    updateMessage(`Target found at index ${i}.`);
                    break;
                }
            }

            if (!stopSorting && !originalValues.includes(target)) updateMessage('Target not found in the array.');
            isSorting = false;
            stopBtn.disabled = true;
        }

        async function binarySearch() {
            isSorting = true;
            stopSorting = false;
            stopBtn.disabled = false;
            const targetRaw = document.getElementById('target-input').value.trim();
            const target = parseInt(targetRaw, 10);
            if (isNaN(target)) {
                updateMessage('Please enter a numeric target to search for.');
                isSorting = false;
                stopBtn.disabled = true;
                return;
            }

            // Ensure array is sorted
            originalValues.sort((a, b) => a - b);
            const maxVal = Math.max(...originalValues);
            data = originalValues.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
            drawBars();

            let left = 0;
            let right = originalValues.length - 1;
            while (left <= right && !stopSorting) {
                const mid = Math.floor((left + right) / 2);
                drawBars(mid, left);
                drawSearchCanvas({ left: left, mid: mid, right: right });
                const val = originalValues[mid];
                const eq = val === target;
                const lt = val < target;
                lastConditionDetail = `Mid index ${mid} value ${val} === target ${target}? ${eq ? 'true' : 'false'}; Less than target? ${lt ? 'true' : 'false'}`;
                updateMessage(`Left=${left}, Right=${right}, Mid=${mid} (value=${val}). Equal? ${eq ? 'true' : 'false'}, Less than target? ${lt ? 'true' : 'false'}.`);
                await pause();
                if (eq) {
                    updateMessage(`Target found at index ${mid}.`);
                    break;
                } else if (lt) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            if (!stopSorting && !originalValues.includes(target)) updateMessage('Target not found in the array.');
            isSorting = false;
            stopBtn.disabled = true;
        }

        startBtn.addEventListener('click', async () => {
            if (isSorting) return;
            
            startBtn.disabled = true;
            exampleDataBtn.disabled = true;
            pauseBtn.disabled = false;
            pauseBtn.textContent = 'Pause';
            isPaused = false;
            
            // Disable step buttons during sorting
            updateStepButtons();
            
            if (selectedAlgorithm === 'bubbleSort') {
                await bubbleSort();
            } else if (selectedAlgorithm === 'insertionSort') {
                await insertionSort();
            } else if (selectedAlgorithm === 'selectionSort') {
                await selectionSort();
            } else if (selectedAlgorithm === 'quickSort') {
                await quickSort();
            } else if (selectedAlgorithm === 'mergeSort') {
                await mergeSort();
            } else if (selectedAlgorithm === 'linearSearch') {
                await linearSearch();
            } else if (selectedAlgorithm === 'binarySearch') {
                await binarySearch();
            } else if (selectedAlgorithm === 'insertMethod') {
                await insertMethod();
            } else if (selectedAlgorithm === 'deleteMethod') {
                await deleteMethod();
            } else if (selectedAlgorithm === 'dijkstra') {
                await dijkstra();
            } else if (selectedAlgorithm === 'astar') {
                await astar();
            } else if (selectedAlgorithm === 'treeDfs') {
                await treeDfsTraversal();
            } else if (selectedAlgorithm === 'treeBfs') {
                await treeBfsTraversal();
            } else {
                // Fallback to bubble sort if algorithm is not recognized
                await bubbleSort();
            }
            
            startBtn.disabled = false;
            exampleDataBtn.disabled = false;
            pauseBtn.disabled = true;
            
            // Re-enable step buttons after sorting
            updateStepButtons();
        });

        pauseBtn.addEventListener('click', ()=>{
            if (!isSorting) return;
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
            updateMessage(isPaused ? 'Paused' : 'Resuming...');
        });

        stopBtn.addEventListener('click', () => {
            if (isSorting) {
                stopSorting = true;
                updateMessage("Stopping the sorting process...");
                // reset pause state
                isPaused = false;
                if (pauseBtn) { pauseBtn.textContent = 'Pause'; pauseBtn.disabled = true; }
                
                // Re-enable step buttons after stopping
                setTimeout(() => updateStepButtons(), 100);
            }
        });

        // Event listeners for step control buttons
        if (stepBackwardBtn) {
            stepBackwardBtn.addEventListener('click', () => {
                if (!isSorting && stepBackward()) {
                    updateMessage("Stepped backward");
                }
            });
        }

        if (stepForwardBtn) {
            stepForwardBtn.addEventListener('click', () => {
                if (!isSorting && stepForward()) {
                    updateMessage("Stepped forward");
                }
            });
        }

        exampleDataBtn.addEventListener('click', () => {
            if (!isSorting) {
                useExampleData = true;
                initializeData();
                updateMessage("Example data loaded!");
            }
        });

        // Insert button triggers insertMethod when applicable
        if (insertAtPosBtn) {
            insertAtPosBtn.addEventListener('click', async () => {
                if (selectedAlgorithm === 'insertMethod' && !isSorting) {
                    await insertMethod();
                }
            });
        }

        // Trigger searches via Enter key in target input
        if (targetInputEl) {
            targetInputEl.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (isSorting) return;
                    if (selectedAlgorithm === 'linearSearch') {
                        await linearSearch();
                    } else if (selectedAlgorithm === 'binarySearch') {
                        await binarySearch();
                    }
                }
            });
        }

        // Pathfinding control event listeners
        const clearGridBtn = document.getElementById('clear-grid');
        const randomizeWallsBtn = document.getElementById('randomize-walls');
        const drawingModeSelect = document.getElementById('drawing-mode');

        if (clearGridBtn) {
            clearGridBtn.addEventListener('click', () => {
                if (!isSorting) {
                    clearGrid();
                    updateMessage("Grid cleared!");
                }
            });
        }

        if (randomizeWallsBtn) {
            randomizeWallsBtn.addEventListener('click', () => {
                if (!isSorting) {
                    randomizeWalls();
                    updateMessage("Walls randomized!");
                }
            });
        }

        if (drawingModeSelect) {
            drawingModeSelect.addEventListener('change', (e) => {
                currentDrawingMode = e.target.value;
                updateMessage(`Drawing mode: ${e.target.value}`);
            });
        }

        // Grid canvas mouse interaction
        if (gridCanvas) {
            gridCanvas.addEventListener('click', handleGridClick);
            
            gridCanvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                handleGridClick(e);
            });
            
            gridCanvas.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    handleGridClick(e);
                }
            });
            
            gridCanvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            gridCanvas.addEventListener('mouseleave', () => {
                isMouseDown = false;
            });
        }

        function initializeData() {
            if (pathfindingAlgos.has(selectedAlgorithm)) {
                // Initialize grid for pathfinding algorithms
                initializeGrid();
                isSorting = false;
                startBtn.disabled = false;
                updatePseudocode();
                messageEl.textContent = 'Ready to find path. Press Start.';
            } else if (treeAlgos.has(selectedAlgorithm)) {
                // Initialize tree for tree traversal algorithms
                createTree();
                isSorting = false;
                startBtn.disabled = false;
                updatePseudocode();
                messageEl.textContent = 'Ready to traverse tree. Press Start.';
            } else {
                if (useExampleData) {
                    originalValues = [...exampleData];
                    const maxVal = Math.max(...exampleData);
                    data = exampleData.map(val => (val / maxVal) * canvas.height * 0.9 + 1);
                } else {
                    originalValues = [];
                    data = [];
                    for (let k = 0; k < NUM_BARS; k++) {
                        const value = Math.floor(Math.random() * 350) + 10;
                        originalValues.push(value);
                        data.push(value);
                    }
                }
                isSorting = false;
                startBtn.disabled = false;
                drawBars();
                if (searchAlgos.has(selectedAlgorithm)) drawSearchCanvas({});
                updatePseudocode();
                messageEl.textContent = 'Ready to visualize. Press Start.';
            }
        }

        window.onload = function() {
            initializeData();
            updateStepButtons();
            loadComparisonData(); // Load existing comparison data
        };

        // Explanation functions for sidebar buttons
        function showAlgorithmExplanation() {
            const explanations = {
                bubbleSort: "Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The algorithm gets its name from the way smaller elements 'bubble' to the top of the list.",
                insertionSort: "Insertion Sort builds the sorted array one item at a time by inserting each new element into its correct position among the already sorted elements. It works like sorting playing cards in your hand.",
                selectionSort: "Selection Sort divides the array into sorted and unsorted parts, repeatedly finding the smallest element from the unsorted part and moving it to the sorted part.",
                quickSort: "Quick Sort is a divide-and-conquer algorithm that picks a pivot element and partitions the array around it. It then recursively sorts the sub-arrays before and after the pivot.",
                mergeSort: "Merge Sort splits the array into halves, recursively sorts each half, and then merges the sorted halves back together using a stable merging process.",
                linearSearch: "Linear Search checks each element in the list one by one until it finds the target value or reaches the end. It's the simplest search algorithm.",
                binarySearch: "Binary Search works on sorted arrays by repeatedly dividing the search interval in half, comparing the middle element to the target, and narrowing the search range.",
                insertMethod: "Insert Method finds the correct position to insert a new value while maintaining the sorted order of the array. It searches for the appropriate position and inserts the element there.",
                deleteMethod: "Delete Method searches for a specific value in the array and removes it if found. It performs a linear search to locate the element and then removes it from the array.",
                // DFS and BFS descriptions removed
                treeDfs: "Tree DFS traverses a tree by going as deep as possible along each branch before backtracking. It visits nodes in pre-order: root, left subtree, right subtree.",
                treeBfs: "Tree BFS traverses a tree level by level, visiting all nodes at the current depth before moving to the next level. It guarantees visiting nodes in breadth-first order."
            };
            
            const explanation = explanations[selectedAlgorithm] || "No explanation available for this algorithm.";
            messageEl.innerHTML = `<strong>📖 Algorithm Explanation:</strong><br><br>${explanation}`;
        }

        function getComplexityClass(complexity) {
            if (complexity.includes('O(1)') || complexity.includes('O(log n)')) {
                return 'complexity-good';
            } else if (complexity.includes('O(n)') && !complexity.includes('O(n²)') && !complexity.includes('O(n log n)')) {
                return 'complexity-moderate';
            } else {
                return 'complexity-poor';
            }
        }

        function getComplexityTooltip(complexity) {
            const tooltips = {
                'O(1)': 'Constant time - always takes the same time regardless of input size',
                'O(log n)': 'Logarithmic time - very efficient, time increases slowly with input size',
                'O(n)': 'Linear time - time increases proportionally with input size',
                'O(n log n)': 'Linearithmic time - efficient for sorting algorithms',
                'O(n²)': 'Quadratic time - time increases with square of input size',
                'O(h)': 'Depends on tree height - best O(log n), worst O(n)',
                'O(w)': 'Depends on tree width - can be up to O(n) in worst case'
            };
            return tooltips[complexity] || 'Time/space complexity notation';
        }

        function toggleComplexityInfo() {
            const complexityBox = document.getElementById('complexityBox');
            const complexityContent = document.getElementById('complexityContent');
            
            if (complexityBox.style.display === 'none' || !complexityBox.style.display) {
                const complexities = {
                    bubbleSort: { 
                        timeBest: 'O(n)', timeAvg: 'O(n²)', timeWorst: 'O(n²)', space: 'O(1)'
                    },
                    insertionSort: { 
                        timeBest: 'O(n)', timeAvg: 'O(n²)', timeWorst: 'O(n²)', space: 'O(1)'
                    },
                    selectionSort: { 
                        timeBest: 'O(n²)', timeAvg: 'O(n²)', timeWorst: 'O(n²)', space: 'O(1)'
                    },
                    quickSort: { 
                        timeBest: 'O(n log n)', timeAvg: 'O(n log n)', timeWorst: 'O(n²)', space: 'O(log n)'
                    },
                    mergeSort: { 
                        timeBest: 'O(n log n)', timeAvg: 'O(n log n)', timeWorst: 'O(n log n)', space: 'O(n)'
                    },
                    linearSearch: { 
                        timeBest: 'O(1)', timeAvg: 'O(n)', timeWorst: 'O(n)', space: 'O(1)'
                    },
                    binarySearch: { 
                        timeBest: 'O(1)', timeAvg: 'O(log n)', timeWorst: 'O(log n)', space: 'O(1)'
                    },
                    insertMethod: { 
                        timeBest: 'O(1)', timeAvg: 'O(n)', timeWorst: 'O(n)', space: 'O(1)'
                    },
                    deleteMethod: { 
                        timeBest: 'O(1)', timeAvg: 'O(n)', timeWorst: 'O(n)', space: 'O(1)'
                    },
                    treeDfs: { 
                        timeBest: 'O(n)', timeAvg: 'O(n)', timeWorst: 'O(n)', space: 'O(h)'
                    },
                    treeBfs: { 
                        timeBest: 'O(n)', timeAvg: 'O(n)', timeWorst: 'O(n)', space: 'O(w)'
                    }
                };
                
                const info = complexities[selectedAlgorithm];
                if (info) {
                    complexityContent.innerHTML = `
                        <div class="complexity-item">
                            <span class="complexity-label">Best Case:</span>
                            <span class="complexity-value complexity-tooltip ${getComplexityClass(info.timeBest)}" data-tooltip="${getComplexityTooltip(info.timeBest)}">${info.timeBest}</span>
                        </div>
                        <div class="complexity-item">
                            <span class="complexity-label">Average:</span>
                            <span class="complexity-value complexity-tooltip ${getComplexityClass(info.timeAvg)}" data-tooltip="${getComplexityTooltip(info.timeAvg)}">${info.timeAvg}</span>
                        </div>
                        <div class="complexity-item">
                            <span class="complexity-label">Worst Case:</span>
                            <span class="complexity-value complexity-tooltip ${getComplexityClass(info.timeWorst)}" data-tooltip="${getComplexityTooltip(info.timeWorst)}">${info.timeWorst}</span>
                        </div>
                        <div class="complexity-item">
                            <span class="complexity-label">Space:</span>
                            <span class="complexity-value complexity-tooltip ${getComplexityClass(info.space)}" data-tooltip="${getComplexityTooltip(info.space)}">${info.space}</span>
                        </div>
                    `;
                } else {
                    complexityContent.innerHTML = '<div>No complexity data available for this algorithm.</div>';
                }
                complexityBox.style.display = 'block';
            } else {
                complexityBox.style.display = 'none';
            }
        }

        function showHowItWorks() {
            const howItWorks = {
                bubbleSort: "1. Compare adjacent elements<br>2. Swap if they're in wrong order<br>3. Repeat for each element<br>4. Continue until no swaps needed",
                insertionSort: "1. Take one element at a time<br>2. Compare with sorted elements<br>3. Insert in correct position<br>4. Shift elements as needed",
                selectionSort: "1. Find minimum in unsorted part<br>2. Swap with first unsorted element<br>3. Move boundary of sorted part<br>4. Repeat until sorted",
                quickSort: "1. Choose a pivot element<br>2. Partition array around pivot<br>3. Recursively sort sub-arrays<br>4. Combine results",
                mergeSort: "1. Divide array into halves<br>2. Recursively sort each half<br>3. Merge sorted halves<br>4. Continue until fully sorted",
                linearSearch: "1. Start from first element<br>2. Compare with target value<br>3. Move to next if not found<br>4. Return index when found",
                binarySearch: "1. Compare target with middle element<br>2. Eliminate half of search space<br>3. Repeat on remaining half<br>4. Continue until found or exhausted",
                insertMethod: "1. Search for insertion position<br>2. Compare with existing elements<br>3. Shift elements to make room<br>4. Insert new element",
                deleteMethod: "1. Search for target element<br>2. Locate element position<br>3. Remove element from array<br>4. Shift remaining elements",
                // DFS and BFS how-it-works information removed
                treeDfs: "1. Visit current node<br>2. Recursively traverse left subtree<br>3. Recursively traverse right subtree<br>4. Backtrack when done",
                treeBfs: "1. Start with root in queue<br>2. Process nodes level by level<br>3. Add children to queue<br>4. Continue until all levels visited"
            };
            
            const steps = howItWorks[selectedAlgorithm] || "No step-by-step information available.";
            messageEl.innerHTML = `<strong>🔧 How It Works:</strong><br><br>${steps}`;
        }

        function showUseCases() {
            const useCases = {
                bubbleSort: "• Educational purposes<br>• Small datasets<br>• Simple implementation<br>• When stability is required",
                insertionSort: "• Small datasets<br>• Nearly sorted data<br>• Hybrid sorting algorithms<br>• Online sorting scenarios",
                selectionSort: "• Memory-constrained environments<br>• When write operations are expensive<br>• Simple implementation needed<br>• Small datasets",
                quickSort: "• General-purpose sorting<br>• Large datasets<br>• In-place sorting<br>• Average-case performance critical",
                mergeSort: "• Stable sorting required<br>• Large datasets<br>• External sorting<br>• Linked lists",
                linearSearch: "• Unsorted data<br>• Small datasets<br>• Finding all occurrences<br>• Simple implementation",
                binarySearch: "• Sorted arrays<br>• Large datasets<br>• Database indexing<br>• Efficient searching",
                insertMethod: "• Dynamic data structures<br>• Database systems<br>• Priority queues<br>• Maintaining sorted order",
                deleteMethod: "• Dynamic data structures<br>• Database management<br>• Memory management<br>• Array manipulation",
                // DFS and BFS use cases information removed
                treeDfs: "• Expression tree evaluation<br>• Directory traversal<br>• Syntax tree parsing<br>• Pre/in/post order traversal",
                treeBfs: "• Level-order printing<br>• Finding tree height<br>• Level-wise processing<br>• Breadth-first operations"
            };
            
            const cases = useCases[selectedAlgorithm] || "No use case information available.";
            messageEl.innerHTML = `<strong>💡 Use Cases:</strong><br><br>${cases}`;
        }
    </script>
  <script>
    (function(){
      const body = document.body;
      const cursor = document.getElementById('waterCursor');
      if (!cursor) return;
      body.classList.add('water-cursor-enabled');

      let rafId = null;
      let targetX = window.innerWidth/2, targetY = window.innerHeight/2;
      let curX = targetX, curY = targetY;

      function loop(){
        curX += (targetX - curX) * 0.25;
        curY += (targetY - curY) * 0.25;
        cursor.style.transform = `translate(${curX}px, ${curY}px)`;
        rafId = requestAnimationFrame(loop);
      }
      rafId = requestAnimationFrame(loop);

      function spawnRipple(x, y){
        const r = document.createElement('div');
        r.className = 'water-ripple';
        r.style.left = x + 'px';
        r.style.top = y + 'px';
        document.body.appendChild(r);
        r.addEventListener('animationend', ()=> r.remove());
      }

      window.addEventListener('mousemove', (e)=>{
        targetX = e.clientX;
        targetY = e.clientY;
        if (Math.random() < 0.05) spawnRipple(targetX, targetY);
      });
      window.addEventListener('click', (e)=>{
        spawnRipple(e.clientX, e.clientY);
      });

      window.addEventListener('blur', ()=> body.classList.remove('water-cursor-enabled'));
      window.addEventListener('focus', ()=> body.classList.add('water-cursor-enabled'));
    })();
  </script>

  <!-- Comparison Toggle Button -->
  <div class="comparison-toggle">
    <button class="comparison-btn" onclick="toggleComparisonPanel()">
      📊 Compare Algorithms
    </button>
  </div>

  <!-- Summary Modal -->
  <div id="summaryModal" class="summary-modal">
    <div class="summary-content">
      <div class="summary-header">
        <h2 class="summary-title">🎉 Algorithm Complete!</h2>
        <p class="summary-algorithm" id="summaryAlgorithmName">Bubble Sort</p>
      </div>
      
      <div class="summary-grid">
        <div class="summary-metric">
          <div class="summary-metric-label">Input Size (N)</div>
          <div class="summary-metric-value" id="summaryInputSize">0</div>
        </div>
        <div class="summary-metric">
          <div class="summary-metric-label">Comparisons</div>
          <div class="summary-metric-value" id="summaryComparisons">0</div>
        </div>
        <div class="summary-metric">
          <div class="summary-metric-label">Swaps/Moves</div>
          <div class="summary-metric-value" id="summarySwaps">0</div>
        </div>
        <div class="summary-metric">
          <div class="summary-metric-label">Time (ms)</div>
          <div class="summary-metric-value" id="summaryTime">0</div>
        </div>
      </div>
      
      <div class="summary-actions">
        <button class="summary-btn summary-btn-primary" onclick="addToComparison()">
          📊 Add to Comparison
        </button>
        <button class="summary-btn summary-btn-secondary" onclick="runAgain()">
          🔄 Run Again
        </button>
        <button class="summary-btn summary-btn-secondary" onclick="closeSummary()">
          ✖️ Close
        </button>
      </div>
    </div>
  </div>

  <!-- Comparison Panel -->
  <div id="comparisonPanel" class="comparison-panel">
    <div class="comparison-header">
      Algorithm Comparison
      <button style="float: right; background: none; border: none; color: #9C27B0; font-size: 1.2em; cursor: pointer;" onclick="toggleComparisonPanel()">✖️</button>
    </div>
    <div id="comparisonList">
      <p style="color: #a0a0a0; text-align: center; margin: 50px 0;">
        No algorithms compared yet.<br>
        Run algorithms and add them to comparison!
      </p>
    </div>
    <div style="margin-top: 20px; text-align: center;">
      <button class="summary-btn summary-btn-secondary" onclick="clearComparisons()" style="width: 100%;">
        🗑️ Clear All
      </button>
    </div>
  </div>
</body>
</html>